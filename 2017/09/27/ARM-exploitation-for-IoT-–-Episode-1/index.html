<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>arm exploitation for iot – episode 1 | 物联网安全技术研究</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="根据作者的安排，文章分为ARM逆向、构造shellcode、最终的exploitation。本篇介绍和ARM逆向相关的知识点。">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM exploitation for IoT – Episode 1">
<meta property="og:url" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/index.html">
<meta property="og:site_name" content="物联网安全技术研究">
<meta property="og:description" content="根据作者的安排，文章分为ARM逆向、构造shellcode、最终的exploitation。本篇介绍和ARM逆向相关的知识点。">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got1.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got2.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got3.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got4.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got5.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/loader1.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace1-1.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace2.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace3.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace4.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace5.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace6.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace8.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace7.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace9.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace10.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace11.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace12.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace13.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace14.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace15.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace16.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace17.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace18.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace19.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace20.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace21.png">
<meta property="og:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace22.png">
<meta property="og:updated_time" content="2017-09-27T05:30:01.118Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ARM exploitation for IoT – Episode 1">
<meta name="twitter:description" content="根据作者的安排，文章分为ARM逆向、构造shellcode、最终的exploitation。本篇介绍和ARM逆向相关的知识点。">
<meta name="twitter:image" content="http://yoursite.com/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got1.png">
  
    <link rel="alternate" href="/atom.xml" title="物联网安全技术研究" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>

<script>
var themeMenus = {};

  themeMenus["/主页"] = "Home"; 

  themeMenus["/书籍"] = "books"; 

  themeMenus["/工具"] = "tools"; 

  themeMenus["/关于我们"] = "About"; 

</script>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="物联网安全技术研究" rel="home"> 物联网安全技术研究 </a>
            
          </h1>

          
            <div class="site-description">一个专注于物联网安全技术研究与交流的小站</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/主页">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/书籍">books</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/工具">tools</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/关于我们">About</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-ARM-exploitation-for-IoT-–-Episode-1" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      ARM exploitation for IoT – Episode 1
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/" class="article-date">
	  <time datetime="2017-09-27T04:43:13.000Z" itemprop="datePublished">September 27, 2017</time>
	</a>

      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>根据作者的安排，文章分为ARM逆向、构造shellcode、最终的exploitation。本篇介绍和ARM逆向相关的知识点。<br><a id="more"></a></p>
<p>原文链接:<a href="https://quequero.org/2017/07/arm-exploitation-iot-episode-1/" target="_blank" rel="external">https://quequero.org/2017/07/arm-exploitation-iot-episode-1/</a><br>关于文中实验的说明:由于编辑人员时间和资源的限制，暂时没有实际验证。如果后续有条件的话，会实际验证一下。<br>关于翻译的说明:遣词造句的功夫还欠缺火候，如有错误，烦请指出。</p>
<h1 id="动机和简介"><a href="#动机和简介" class="headerlink" title="动机和简介"></a>动机和简介</h1><p>在前几周的一个会议上，我注意到针对ARM平台的漏洞利用课程的价格有点贵，我觉得我可以自己来写一些教程，让那些无法支付昂贵学费的人也能学习这些相关技能。本课程分为三个章节。<br>我仅仅是在做出自己的贡献，这些文章是不能与现场课程相媲美的。</p>
<p>内容将划分如下:</p>
<p>第1章:逆向ARM应用程序<br>第2章:ARM shellcode<br>第3章:ARM漏洞利用</p>
<h1 id="逆向ARM应用程序"><a href="#逆向ARM应用程序" class="headerlink" title="逆向ARM应用程序"></a>逆向ARM应用程序</h1><p><em>环境</em>:树莓派3<br>我选择了一个比较便宜和容易配置的硬件环境，当然了，安卓也是一个不错的选择。</p>
<p><em>硬件</em>:教程所用硬件的型号:<br>Raspberry Pi 3 Model B ARM-Cortex-A53</p>
<p><em>软件</em>:该教程所使用的软件信息:</p>
<pre><code>root@raspberrypi:/home/pi# cat /etc/os-release
PRETTY_NAME=&quot;Raspbian GNU/Linux 8 (jessie)&quot;
NAME=&quot;Raspbian GNU/Linux&quot;
VERSION_ID=&quot;8&quot;
VERSION=&quot;8 (jessie)&quot;
ID=raspbian
ID_LIKE=debian
HOME_URL=&quot;http://www.raspbian.org/&quot;
SUPPORT_URL=&quot;http://www.raspbian.org/RaspbianForums&quot;
BUG_REPORT_URL=&quot;http://www.raspbian.org/RaspbianBugs&quot;

root@raspberrypi:/home/pi#cat /etc/rpi-issue
Raspberry Pi reference 2017-03-02
Generated using pi-gen, https://github.com/RPi-Distro/pi-gen, f563e32202fad7180c9058dc3ad70bfb7c09f0fb, stage2
</code></pre><p><a href="https://www.raspberrypi.org/documentation/installation/installing-images/linux.md" target="_blank" rel="external">如何安装教程中所用操作系统</a><br><a href="https://www.raspberrypi.org/documentation/remote-access/ssh/" target="_blank" rel="external">如何配置ssh远程连接</a></p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>对于所有代码(C，C ++，汇编)，我们将使用Gnu编译器集合(GCC)，Raspbian操作系统自带。GCC的版本是</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc --version
gcc (Raspbian 4.9.2-10) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre><p>另外需要说明的是，GCC的ARM汇编指令根其他编译器不一样，<a href="http://www.ic.unicamp.br/~celio/mc404-2014/docs/gnu-arm-directives.pdf" target="_blank" rel="external">我建议你看看这些指令说明</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/invictus1306/ARM-episodes/tree/master/Episode1" target="_blank" rel="external">教程的代码都在我的github上</a></p>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>对于编译选项必须要知道和理解，在本节中，我们将看到3个不同的选项，并且对于每个选项将进行一个实际的例子。<br>我们用下面的例子作为所有选项演示的例子(文件:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/compiler_options.c" target="_blank" rel="external">compiler_options.c</a>)</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
static char password[] = &quot;compiler_options&quot;;

int main()
{
    char input_pwd[20]={0};
    fgets(input_pwd, sizeof(input_pwd), stdin);
    int size = sizeof(password);
    if(input_pwd[size] != 0)
    {
        printf(&quot;The password is not correct! \n&quot;);
        return 0;
    }
    int ret = strncmp(password, input_pwd, size-1);

    if (ret==0)
    {
        printf(&quot;Good done! \n&quot;);
    }
    else
    {
        printf(&quot;The password is not correct! \n&quot;);
    }
    return 0;
}
</code></pre><h2 id="调试符号"><a href="#调试符号" class="headerlink" title="调试符号"></a>调试符号</h2><p>选项-g产生存储在可执行文件中的调试信息(符号表)。编译我们的例子（compiler_options.c），比较带“-g”选项和不带“-g”选项所产生可执行文件的大小。</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc -o compiler_options compiler_options.c
root@raspberrypi:/home/pi/arm/episode1# ls -l
total 12
-rwxr-xr-x 1 root root 6288 Jun 14 20:21 compiler_options
-rw-r--r-- 1 root root 488 Jun 14 19:41 compiler_options.c
root@raspberrypi:/home/pi/arm/episode1# gcc -o compiler_options compiler_options.c -g
root@raspberrypi:/home/pi/arm/episode1# ls -l
total 16
-rwxr-xr-x 1 root root 8648 Jun 14 20:21 compiler_options
-rw-r--r-- 1 root root 488 Jun 14 19:41 compiler_options.c
</code></pre><p>我们可以看到，在第二种情况下，文件较大，这意味着有一些信息已添加到ELF文件中。<br>我们可以使用不同的方法查看可执行文件中的调试信息，我们用readelf程序，加上-S选项（显示section的头）。</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# readelf -S compiler_options | grep debug
[27] .debug_aranges PROGBITS 00000000 0007f2 000020 00 0 0 1
[28] .debug_info PROGBITS 00000000 000812 000318 00 0 0 1
[29] .debug_abbrev PROGBITS 00000000 000b2a 0000da 00 0 0 1
[30] .debug_line PROGBITS 00000000 000c04 0000de 00 0 0 1
[31] .debug_frame PROGBITS 00000000 000ce4 000030 00 0 0 4
[32] .debug_str PROGBITS 00000000 000d14 000267 01 MS 0 0 1
</code></pre><p>您可以看到包含以DWARF调试格式存储的调试信息的所有部分，这是GCC编译器使用的默认调试格式。<br>可以用objdump查看section的详细数据</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# objdump --dwarf=info ./compiler_options
…
Abbrev Number: 14 (DW_TAG_variable)
DW_AT_name : (indirect string, offset: 0x8a): password
DW_AT_decl_file : 1
DW_AT_decl_line : 4
DW_AT_type : &lt;0x2eb&gt;
DW_AT_location : 5 byte block: 3 70 7 2 0 (DW_OP_addr: 20770)
Abbrev Number: 16 (DW_TAG_variable)
DW_AT_name : (indirect string, offset: 0x215): stdin
DW_AT_decl_file : 5
DW_AT_decl_line : 168
DW_AT_type : &lt;0x26b&gt;
DW_AT_external : 1
DW_AT_declaration : 1
Abbrev Number: 0
</code></pre><p>上面显示的是debug_info section的信息，这些信息在调试的时候被调试器使用。</p>
<h2 id="删除所有符号表和重定位信息"><a href="#删除所有符号表和重定位信息" class="headerlink" title="删除所有符号表和重定位信息"></a>删除所有符号表和重定位信息</h2><p>使用GCC编译器，我们可以删除所有的符号表和重定位信息，这样做的选项是-s。</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc -o compiler_options compiler_options.c
root@raspberrypi:/home/pi/arm/episode1# readelf --sym compiler_options
Symbol table &apos;.dynsym&apos; contains 8 entries:
Num: Value Size Type Bind Vis Ndx Name
0: 00000000 0 NOTYPE LOCAL DEFAULT UND
1: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__
2: 00000000 0 FUNC GLOBAL DEFAULT UND fgets@GLIBC_2.4 (2)
3: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.4 (2)
4: 00020788 4 OBJECT GLOBAL DEFAULT 24 stdin@GLIBC_2.4 (2)
5: 00000000 0 FUNC GLOBAL DEFAULT UND strncmp@GLIBC_2.4 (2)
6: 00000000 0 FUNC GLOBAL DEFAULT UND abort@GLIBC_2.4 (2)
7: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.4 (2)
Symbol table &apos;.symtab&apos; contains 115 entries:
Num: Value Size Type Bind Vis Ndx Name
0: 00000000 0 NOTYPE LOCAL DEFAULT UND
1: 00010134 0 SECTION LOCAL DEFAULT 1
2: 00010150 0 SECTION LOCAL DEFAULT 2
...
112: 00000000 0 FUNC GLOBAL DEFAULT UND strncmp@@GLIBC_2.4
113: 00000000 0 FUNC GLOBAL DEFAULT UND abort@@GLIBC_2.4
114: 00010318 0 FUNC GLOBAL DEFAULT 11 _init
</code></pre><p>正如我们所看到的那样。symtab具有许多局部符号，这些不是运行程序所必需的，因此可以删除此部分。</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc -o compiler_options compiler_options.c -s
root@raspberrypi:/home/pi/arm/episode1# readelf --sym compiler_options
Symbol table &apos;.dynsym&apos; contains 8 entries:
Num: Value Size Type Bind Vis Ndx Name
0: 00000000 0 NOTYPE LOCAL DEFAULT UND
1: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__
2: 00000000 0 FUNC GLOBAL DEFAULT UND fgets@GLIBC_2.4 (2)
3: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.4 (2)
4: 00020788 4 OBJECT GLOBAL DEFAULT 24 stdin@GLIBC_2.4 (2)
5: 00000000 0 FUNC GLOBAL DEFAULT UND strncmp@GLIBC_2.4 (2)
6: 00000000 0 FUNC GLOBAL DEFAULT UND abort@GLIBC_2.4 (2)
7: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.4 (2)
</code></pre><p>使用-s选项进行编译后，函数名和一些其他的信息被移除，逆向起来就有点困难了。在第三章，我们将看到其余一些对于漏洞利用来说很重要的编译选项。</p>
<h2 id="ARM-Hello-World"><a href="#ARM-Hello-World" class="headerlink" title="ARM Hello World"></a>ARM Hello World</h2><p>我们将首先编写一个简单的hello world程序，我们将以两种不同的方式来实现：</p>
<pre><code>1.使用Raspbian系统调用
2.使用libc函数
</code></pre><h3 id="使用Raspbian系统调用"><a href="#使用Raspbian系统调用" class="headerlink" title="使用Raspbian系统调用"></a>使用Raspbian系统调用</h3><p>首先，通过Raspbian系统调用来编写一个简单的Hello World程序(源文件:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/rasp_syscall.s" target="_blank" rel="external">rasp_syscall.s</a>)</p>
<pre><code>.data
string: .asciz &quot;Hello World!\n&quot;
len = . - string
.text
.global _start
_start:
    mov r0, #1      @ stdout
    ldr r1, =string @ string address
    ldr r2, =len    @ string length
    mov r7, #4      @ write syscall
    swi 0           @ execute syscall
_exit:
    mov r7, #1      @ exit syscall
    swi 0           @ execute syscall
</code></pre><p>然后汇编、链接</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# as -o rasp_syscall.o rasp_syscall.s
root@raspberrypi:/home/pi/arm/episode1# ld -o rasp_syscall rasp_syscall.o
</code></pre><p>注意:如果我们直接GCC编译的话，会出错:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc -o rasp_syscall rasp_syscall.s
/tmp/ccChPTEP.o: In function `_start&apos;:
(.text+0x0): multiple definition of `_start&apos;
/usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o:/build/glibc-g3vikB/glibc-2.19/csu/../ports/sysdeps/arm/start.S:79: first defined here
/usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o: In function `_start&apos;:
/build/glibc-g3vikB/glibc-2.19/csu/../ports/sysdeps/arm/start.S:119: undefined reference to `main&apos;
collect2: error: ld returned 1 exit status
</code></pre><p>编译器会提示我们找不到main函数:</p>
<pre><code>undefined reference to `main&apos;
</code></pre><p>因为我们确实没有在程序中实现main函数。关于GCC汇编，我们会在接下来的例子中看到。执行链接后的程序：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# ./rasp_syscall
Hello World!
</code></pre><p>再试试用gdb加载程序：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gdb -q ./rasp_syscall
Reading symbols from ./rasp_syscall...(no debugging symbols found)...done.
(gdb) info files
Symbols from &quot;/home/pi/arm/episode1/rasp_syscall&quot;.
Local exec file:
`/home/pi/arm/episode1/rasp_syscall&apos;, file type elf32-littlearm.
Entry point: 0x10074
0x00010074 - 0x00010094 is .text
0x00020094 - 0x000200a2 is .data
(gdb) b *0x00010074
Breakpoint 1 at 0x10074
(gdb) r
Starting program: /home/pi/arm/episode1/rasp_syscall
Breakpoint 1, 0x00010074 in _start ()
(gdb) x/7i $pc
=&gt;    0x10074 &lt;_start&gt;: mov r0, #1
    0x10078 &lt;_start+4&gt;: ldr r1, [pc, #16] ; 0x10090 &lt;_exit+8&gt;
    0x1007c &lt;_start+8&gt;: mov r2, #14
    0x10080 &lt;_start+12&gt;: mov r7, #4
    0x10084 &lt;_start+16&gt;: svc 0x00000000
    0x10088 &lt;_exit&gt;: mov r7, #1
    0x1008c &lt;_exit+4&gt;: svc 0x00000000
</code></pre><p>我们可以看到.text段的指令。地址0x10078处的指令会将pc+16的值给r1寄存器。也就是r1=0x10080+16=0x10090。<br>看一下这个地址放着什么数据：</p>
<pre><code>(gdb) x/14c *(int*)0x10090
0x20094: 72 &apos;H&apos; 101 &apos;e&apos; 108 &apos;l&apos; 108 &apos;l&apos; 111 &apos;o&apos; 32 &apos; &apos; 87 &apos;W&apos; 111 &apos;o&apos;
0x2009c: 114 &apos;r&apos; 108 &apos;l&apos; 100 &apos;d&apos; 33 &apos;!&apos; 10 &apos;\n&apos; 0 &apos;\000&apos;
</code></pre><h3 id="使用libc函数"><a href="#使用libc函数" class="headerlink" title="使用libc函数"></a>使用libc函数</h3><p>这次用printf实现Hello world。但是还要做一些调整，比如说要将全局的_start符号换成_main符号，我会在接下来详细介绍。<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/libc_functions.s" target="_blank" rel="external">源码文件</a></p>
<pre><code>.data
string: .asciz &quot;Hello World!\n&quot;
.text
.global main
.func main
main:
    stmfd sp!, {lr}    @ save lr
    ldr r0, =string    @ store string address into R0
    bl printf          @ call printf
    ldmfd sp!, {pc}    @ restore pc
_exit:
    mov lr, pc         @ exit
</code></pre><p>编译器用新定义的符号(.global main,.func main,main:)告诉libc库程序的main函数在哪里。<br>像上文那样执行汇编、链接：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# as -o libc_functions.o libc_functions.s
root@raspberrypi:/home/pi/arm/episode1# ld -o libc_functions libc_functions.o
ld: warning: cannot find entry symbol _start; defaulting to 00010074
libc_functions.o: In function `main&apos;:
(.text+0x8): undefined reference to `printf&apos;
</code></pre><p>但是好像出错了，找找原因。汇编器和链接器只是GCC编译器很小的组成部分，而libc库由GCC来提供给程序使用(当然手动链接一些共享库也是可行的)，所以直接汇编、链接的话程序会找不到printf函数。<br>来看看gcc怎么编译程序：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc -o libc_functions libc_functions.s
</code></pre><p>用gdb加载：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gdb -q ./libc_functions
Reading symbols from ./libc_functions...(no debugging symbols found)...done.
(gdb) b main
Breakpoint 1 at 0x10420
(gdb) r
Starting program: /home/pi/arm/episode1/libc_functions
Breakpoint 1, 0x00010420 in main ()
(gdb) info proc mappings
process 2023
Mapped address spaces:
Start Addr End Addr Size Offset objfile
0x10000 0x11000 0x1000 0x0 /home/pi/arm/episode1/libc_functions
0x20000 0x21000 0x1000 0x0 /home/pi/arm/episode1/libc_functions
0x76e79000 0x76fa4000 0x12b000 0x0 /lib/arm-linux-gnueabihf/libc-2.19.so
0x76fa4000 0x76fb4000 0x10000 0x12b000 /lib/arm-linux-gnueabihf/libc-2.19.so
0x76fb4000 0x76fb6000 0x2000 0x12b000 /lib/arm-linux-gnueabihf/libc-2.19.so
0x76fb6000 0x76fb7000 0x1000 0x12d000 /lib/arm-linux-gnueabihf/libc-2.19.so
0x76fb7000 0x76fba000 0x3000 0x0
0x76fba000 0x76fbf000 0x5000 0x0 /usr/lib/arm-linux-gnueabihf/libarmmem.so
0x76fbf000 0x76fce000 0xf000 0x5000 /usr/lib/arm-linux-gnueabihf/libarmmem.so
0x76fce000 0x76fcf000 0x1000 0x4000 /usr/lib/arm-linux-gnueabihf/libarmmem.so
0x76fcf000 0x76fef000 0x20000 0x0 /lib/arm-linux-gnueabihf/ld-2.19.so
0x76ff1000 0x76ff3000 0x2000 0x0
0x76ff9000 0x76ffb000 0x2000 0x0
0x76ffb000 0x76ffc000 0x1000 0x0 [sigpage]
0x76ffc000 0x76ffd000 0x1000 0x0 [vvar]
0x76ffd000 0x76ffe000 0x1000 0x0 [vdso]
0x76ffe000 0x76fff000 0x1000 0x1f000 /lib/arm-linux-gnueabihf/ld-2.19.so
0x76fff000 0x77000000 0x1000 0x20000 /lib/arm-linux-gnueabihf/ld-2.19.so
0x7efdf000 0x7f000000 0x21000 0x0 [stack]
0xffff0000 0xffff1000 0x1000 0x0 [vectors]
可以看到libc共享库(libc-2.19.so)被加载到进程空间了。让我们看看程序源码:
(gdb) x/5i $pc
=&gt;  0x10420 &lt;main&gt;: stmfd   sp!, {lr} 
    0x10424 &lt;main+4&gt;:  ldr r0, [pc, #8]    ; 0x10434 &lt;_exit+4&gt; 
    0x10428 &lt;main+8&gt;:  bl  0x102c8 
    0x1042c &lt;main+12&gt;: ldmfd   sp!, {pc} 
    0x10430 &lt;_exit&gt;:   mov lr, pc
</code></pre><p>在地址0x10428处是对printf函数的调用，从更详细的实现细节来说，0x10428处的指令只是PLT（过程链接表）的入口，每个PLT在包含函数真实地址的GOT段中都有对应的表项。来看看细节。<br>当我们使用GCC编译程序时，libc不包含在二进制文件（libc_functions）中，但是libc将动态链接到这个二进制文件。我们可以使用ldd查看从这个二进制文件引用的动态库：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# ldd libc_functions
linux-vdso.so.1 (0x7eeb1000)
/usr/lib/arm-linux-gnueabihf/libarmmem.so (0x76fe6000)
libc.so.6 =&gt; /lib/arm-linux-gnueabihf/libc.so.6 (0x76e9f000)
/lib/ld-linux-armhf.so.3 (0x54b6d000)
</code></pre><p>我们可以看到libc是二进制文件所必需的，如果你运行ldd otehrs的时候你可以注意到，libc的地址是不同的，这是因为ASLR被启用。我们用IDA打开二进制文件<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got1.png" alt=""></p>
<p>在0x10428位置有对printf函数的调用，我们可以注意到我们没有到达libc<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got2.png" alt=""></p>
<p>但是我们在PLT部分，在0x102D0行，我们可以看到跳转（LDR PC，[…]）到存储在另一个位置的地址<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got3.png" alt=""></p>
<p>我们进入GOT部分，可以看到这里存储的是一个外部符号的地址。<br>使用gdb进行调试的时候，我们可以在0x10428地址设置一个断点（在main函数中调用printf函数）</p>
<pre><code>Breakpoint 2, 0x00010428 in main ()Breakpoint 2, 0x00010428 in main ()
(gdb) x/i $pc
=&gt; 0x10428 &lt;main+8&gt;: bl 0x102c8
</code></pre><p>继续执行stepi命令<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got4.png" alt=""></p>
<p>如果我们继续执行几个指令，我们将达到ld二进制文件中包含的dl_runtime_resolve函数<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/plt_got5.png" alt=""></p>
<p>ldd是一个动态的链接器，它的功能就是确定程序应用了哪些libc库。<br>关于本节更详细的介绍在<a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="external">http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/</a></p>
<h2 id="逆向工程介绍"><a href="#逆向工程介绍" class="headerlink" title="逆向工程介绍"></a>逆向工程介绍</h2><p>在本节中，我只在分析algorithm_reversing程序的时候罗列一下的源码，其余程序的源码不再特意贴上来。</p>
<h3 id="逆向算法"><a href="#逆向算法" class="headerlink" title="逆向算法"></a>逆向算法</h3><p>我们从一个真正简单的程序开始，它接收一个消息，这个消息由一个简单的算法处理，并输出另一个消息。本练习的目的是了解所使用的算法，使得输出消息是字符串“Hello”。</p>
<pre><code>strIN -------[algorithm]-------strOUT
strOUT = Hello
</code></pre><p><a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/algorithm_reversing.s" target="_blank" rel="external">源码</a></p>
<pre><code>.data
.balign 4
    info: .asciz &quot;Please enter your string: &quot;
    format: .asciz &quot;%5s&quot;
.balign 4
    strIN: .skip 5
    strOUT: .skip 5
    val: .byte 0x5
    output: .asciz &quot;your input: %s\n&quot;
.text
.global main
.extern printf
.extern scanf

main:
    push {ip, lr}      @ push return address + dummy register
    ldr r0, =info      @ print the info
    bl printf
    ldr r0, =format
    ldr r1, =strIN
    bl scanf
    @ parsing of the message
    ldr r5, =strOUT
    ldr r1, =strIN
    ldrb r2, [r1]
    ldrb r3, [r1,#1]
    eor r0, r2, r3
    str r0, [r5]
    ldrb r4, [r1,#2]
    eor r0, r4, r3
    str r0, [r5,#1]
    add r2, #0x5
    str r2, [r5,#2]
    ldrb r4, [r1,#3]
    eor r0, r3, r4
    str r0, [r5,#3]
    ldrb r2, [r1,#4]
    eor r0, r2, r4
    str r0, [r5,#4]
    @ print of the final string
    ldr r0, =strOUT    @ print num formatted by output string.
    bl printf
    pop {ip, pc}       @ pop return address into pc
</code></pre><p>编译：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gcc -o algorithm_reversing algorithm_reversing.s
</code></pre><p>调试它：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gdb -q ./algorithm_reversing
Reading symbols from ./algorithm_reversing...(no debugging symbols found)...done.
(gdb) b main
Breakpoint 1 at 0x10450
(gdb) r
Starting program: /home/pi/arm/episode1/algorithm_reversing
Breakpoint 1, 0x00010450 in main ()
(gdb) x/10i $pc
=&gt;    0x10450 &lt;main&gt;: push    {r12, lr} 
    0x10454 &lt;main+4&gt;:  ldr r0, [pc, #92]   ; 0x104b8 &lt;main+104&gt; 
    0x10458 &lt;main+8&gt;:  bl  0x102ec 
    0x1045c &lt;main+12&gt;: ldr r0, [pc, #88]   ; 0x104bc &lt;main+108&gt; 
    0x10460 &lt;main+16&gt;: ldr r1, [pc, #88]   ; 0x104c0 &lt;main+112&gt; 
    0x10464 &lt;main+20&gt;: bl  0x10304 
    0x10468 &lt;main+24&gt;: ldr r5, [pc, #84]   ; 0x104c4 &lt;main+116&gt; 
    0x1046c &lt;main+28&gt;: ldr r1, [pc, #76]   ; 0x104c0 &lt;main+112&gt; 
    0x10470 &lt;main+32&gt;: ldrb    r2, [r1] 
    0x10474 &lt;main+36&gt;: ldrb    r3, [r1, #1]
</code></pre><p>执行到0x10454，这条指令的意思是</p>
<pre><code>r0=*(pc+92)
</code></pre><p>看看pc+92处存放的是什么数据：</p>
<pre><code>(gdb) x/x 0x104b8
0x104b8 &lt;main+104&gt;:   0x00020668
</code></pre><p>存放的是一个地址，这个地址位于数据段：</p>
<pre><code>(gdb) x/s 0x20668
0x20668: &quot;Please enter your string: &quot;
</code></pre><p>存放的是printf的第一个参数。<br>在地址0x10464处调用scanf函数，r0参数是格式化字符串地址，r1参数是接收输入的地址。</p>
<pre><code>(gdb) i r $r0 $r1
r0 0x20683 132739
r1 0x20688 132744
(gdb) nexti
</code></pre><p>从源码中能看出，需要输入5个字符：</p>
<pre><code>format: .asciz &quot;%5s&quot;
strIN: .skip
</code></pre><p>然后我们可以输入字符串“ABCDE”</p>
<pre><code>(gdb) nexti
Please enter your string: ABCDE
</code></pre><p>执行0x10468和0x1046c两条指令，将输出字符串地址给r5，将输入字符串地址给r1，接着执行0x10470（算法部分）处的指令</p>
<pre><code>(gdb) x/18i $pc 
=&gt;    0x10470 &lt;main+32&gt;:  ldrb    r2, [r1] 
    0x10474 &lt;main+36&gt;: ldrb    r3, [r1, #1] 
    0x10478 &lt;main+40&gt;: eor r0, r2, r3 
    0x1047c &lt;main+44&gt;: str r0, [r5] 
    0x10480 &lt;main+48&gt;: ldrb    r4, [r1, #2] 
    0x10484 &lt;main+52&gt;: eor r0, r4, r3 
    0x10488 &lt;main+56&gt;: str r0, [r5, #1] 
    0x1048c &lt;main+60&gt;: add r2, r2, #5 
    0x10490 &lt;main+64&gt;: str r2, [r5, #2] 
    0x10494 &lt;main+68&gt;: ldrb    r4, [r1, #3] 
    0x10498 &lt;main+72&gt;: eor r0, r3, r4 
    0x1049c &lt;main+76&gt;: str r0, [r5, #3] 
    0x104a0 &lt;main+80&gt;: ldrb    r2, [r1, #4] 
    0x104a4 &lt;main+84&gt;: eor r0, r2, r4 
    0x104a8 &lt;main+88&gt;: str r0, [r5, #4] 
    0x104ac &lt;main+92&gt;: ldr r0, [pc, #16]   ; 0x104c4 &lt;main+116&gt; 
    0x104b0 &lt;main+96&gt;: bl  0x102ec 
    0x104b4 &lt;main+100&gt;:    pop {r12, pc} 
</code></pre><p>我们来看看下面的指令（参见行内注释）</p>
<pre><code>0x10470 &lt;main+32&gt;: ldrb    r2, [r1]        ; r2 &lt;- *r1
0x10474 &lt;main+36&gt;: ldrb    r3, [r1, #1]  ; r3 &lt;-*(r1+1)
0x10478 &lt;main+40&gt;: eor r0, r2, r3     ; r0=r2 xor r3
0x1047c &lt;main+44&gt;: str r0, [r5]        ; r0 -&gt; *r5
</code></pre><p>继续执行0x10480地址（用nexti），并检查r0，r2和r3寄存器的内容</p>
<pre><code>(gdb) i r $r0 $r2 $r3
r0 0x3 3
r2 0x41 65
r3 0x42 66
</code></pre><p>计算过程是</p>
<pre><code>*r5 = r2 xor r3
</code></pre><p>也就是说输出字符串第一个字节为</p>
<pre><code>byte1strOut = byte1strInput xor byte2strInput
</code></pre><p>我们继续从地址0x10480分析</p>
<pre><code>(gdb) x/8i $pc 
=&gt;    0x10480 &lt;main+48&gt;:  ldrb    r4, [r1, #2] 
    0x10484 &lt;main+52&gt;: eor r0, r4, r3 
    0x10488 &lt;main+56&gt;: str r0, [r5, #1] 
    0x1048c &lt;main+60&gt;: add r2, r2, #5 
    0x10490 &lt;main+64&gt;: str r2, [r5, #2] 
    0x10494 &lt;main+68&gt;: ldrb    r4, [r1, #3] 
    0x10498 &lt;main+72&gt;: eor r0, r3, r4 
    0x1049c &lt;main+76&gt;: str r0, [r5, #3]
</code></pre><p>我们来看看下面的指令（参见行内注释）</p>
<pre><code>0x10480 &lt;main+48&gt;: ldrb    r4, [r1, #2]   ; r4 &lt;- *(r1+2) 
0x10484 &lt;main+52&gt;: eor r0, r4, r3      ; r0=r4 xor r3
0x10488 &lt;main+56&gt;: str r0, [r5, #1]   ; r0 -&gt; *(r5+1)
</code></pre><p>我们来看看0x1048c指令，看看寄存器r0，r3和r4的内容</p>
<pre><code>(gdb) i r $r0 $r3 $r4
r0 0x1 1
r3 0x42 66
r4 0x43 67
计算过程是
*(r5+1) = r4 xor r3
</code></pre><p>也就是说输出字符串第二个字节为</p>
<pre><code>byte2strOut = byte2strInput xor byte3strInput
</code></pre><p>继续，让我们分析这两个指令</p>
<pre><code>0x1048c &lt;main+60&gt;:    add r2, r2, #5 
0x10490 &lt;main+64&gt;:    str r2, [r5, #2] 
</code></pre><p>计算过程是</p>
<pre><code>*(r5+2) = r2 + 0x5
</code></pre><p>也就是说输出字符串第三个字节为</p>
<pre><code>byte3outStr = byte1strInput + 0x5
</code></pre><p>接下来计算输出字符串第四个字节</p>
<pre><code>0x10494 &lt;main+68&gt;:    ldrb    r4, [r1, #3] 
0x10498 &lt;main+72&gt;:    eor r0, r3, r4 
0x1049c &lt;main+76&gt;:    str r0, [r5, #3]
</code></pre><p>计算过程是</p>
<pre><code>*(r5+3) = r3 xor r4
</code></pre><p>也就是说输出字符串第四个字节为</p>
<pre><code>byte4strOut = byte2strInput xor byte4strInput
</code></pre><p>最后是输出字符串第五个字节</p>
<pre><code>0x104a0 &lt;main+80&gt;:    ldrb    r2, [r1, #4] 
0x104a4 &lt;main+84&gt;:    eor r0, r2, r4 
0x104a8 &lt;main+88&gt;:    str r0, [r5, #4]
</code></pre><p>计算过程是</p>
<pre><code>*(r5+4) = r4 xor r2
</code></pre><p>也就是说输出字符串第四个字节为</p>
<pre><code>byte5strOut = byte4strInput xor byte5strInput
</code></pre><p>现在我们可以把计算五个字节的方法罗列一下</p>
<pre><code>byte1strOut = byte1strInput xor byte2strInput
byte2strOut = byte2strInput xor byte3strInput
byte3strOut = byte2strInput + 0x5
byte4strOut = byte2strInput xor byte4strInput
byte5strOut = byte4strInput xor byte5strInput
</code></pre><p>将等式左边的符号替换成我们想要的”Hello”字符串</p>
<pre><code>‘H’ = 0x48 = byte1strInput xor byte2strInput
‘e’ = 0x65 = byte2strInput xor byte3strInput
‘l’ = 0x6c = byte1strInput + 0x5
‘l’ = 0x6c = byte2strInput xor byte4strInput
‘o’ = 0x6f = byte4strInput xor byte5strInput
</code></pre><p>解方程</p>
<pre><code>byte1strInput = 0x6c – 0x5 = 0x67 (g)
byte2strInput = 0x48 xor 0x67 = 0x2f (/)
byte3strInput = 0x2f xor 0x65 = 0x4a (J)
byte4strInput = 0x2f xor 0x6c = 0x43 (C)
byte5strInput = 0x43 xor 0x6f = 0x2c (,)
</code></pre><p>该算法似乎已经解决了，我们来试试一下</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# ./algorithm_reversing
Please enter your string: g/JC,
Hello
</code></pre><h3 id="逆向一个简单的加载器"><a href="#逆向一个简单的加载器" class="headerlink" title="逆向一个简单的加载器"></a>逆向一个简单的加载器</h3><p>这个新程序是一个简单的加载程序，它的任务是加载指令到内存中，并执行这条指令此练习的目的是打印以下传出的消息：“WIN”。您必须在调试过程中更改xor key的值来打印“WIN”字符串<br>程序名称是：<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/loader_reversing" target="_blank" rel="external">loader_reversing</a></p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# file loader_reversing
loader_reversing: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped
root@raspberrypi:/home/pi/arm/episode1# strings loader_reversing
Andrea Sindoni @invictus1306
aeabi
.symtab
.strtab
.shstrtab
.text
.data
.ARM.attributes
loader_reversing.o
mystr
code
_loop
_exit
_bss_end__
__bss_start__
__bss_end__
_start
__bss_start
__end__
_edata
_end
</code></pre><p>用IDA打开文件<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/loader1.png" alt=""></p>
<p>我们可以在_start例程中看到系统调用被调用（地址0x10090），系统调用号为0xc0（mmap syscall）让我们详细分析一下</p>
<pre><code>mov r4, #0xffffffff  @file descriptor
ldr r0, =0x00030000  @address
ldr r1, =0x1000      @size of the mapping table
mov r2, #7           @prot
mov r3, #0x32        @flags
mov r5, #0           @offset
mov r7, #192         @syscall number
swi #0 @ mmap2(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, -1, 0)
</code></pre><p>在mmap系统调用之后，我们可以看到新的分配区域（0x30000）</p>
<pre><code>(gdb) info proc mappings
process 2405
Mapped address spaces:
Start Addr End Addr Size Offset objfile
0x10000 0x11000 0x1000 0x0 /home/pi/arm/episode1/loader_reversing
0x20000 0x21000 0x1000 0x0 /home/pi/arm/episode1/loader_reversing
0x30000 0x31000 0x1000 0x0
0x76ffd000 0x76ffe000 0x1000 0x0 [sigpage]
0x76ffe000 0x76fff000 0x1000 0x0 [vvar]
0x76fff000 0x77000000 0x1000 0x0 [vdso]
0x7efdf000 0x7f000000 0x21000 0x0 [stack]
0xffff0000 0xffff1000 0x1000 0x0 [vectors]
0x10098处的指令    .text:00010098 LDR R1, =code将变量code的地址给r1，来看看code存放的数据
(gdb) i r $r1
r1 0x200f1 131313
(gdb) x/10x 0x200f1
0x200f1: 0xe93f7c56 0xe25fe45e 0xe1b2745b 0xe3b21468
0x20101: 0xe3b20454 0xe3b264c0 0xe0302453 0xe49f2457
0x20111: 0xe2501448 0xe0302453
</code></pre><p>这些字节似乎不像arm代码，然后继续执行0x100A4指令</p>
<pre><code>.text:000100A4 LDR R2, [R1,R4]
</code></pre><p>r2=*(r1+r4),其中r4第一次参与计算时候等于0。看下一条指令</p>
<pre><code>.text:000100A8 EOR R2, R2, R6
</code></pre><p>r2和r6异或，此时r2的值为0x56，r6,为0x12345。xor操作的结果存储在r2中，在下一条指令中将r2的值保存到mmap分配的0x30000地址开始的区域（注意r0是mmap系统调用的返回值）</p>
<pre><code>.text:000100AC STR R2, [R0,R4]
</code></pre><p>该循环用于解密代码变量的所有字节，为了解密，我们将使用gdb（之后我们也将使用IDA做这个），然后在地址0x100BC设置断点，并查看地址0x30000</p>
<pre><code>(gdb) b *0x100bc 
Breakpoint 3 at 0x100bc 
(gdb) c 
Continuing. 
Breakpoint 3, 0x000100bc in _loop () 
(gdb) x/24i 0x30000 
    0x30000: push {r11, lr} 
    0x30004: sub sp, sp, #8 
    0x30008: mov r4, sp 
    0x3000c: mov r2, #62 ; 0x3e 
    0x30010: mov r3, #2 
    0x30014: mov r5, #150 ; 0x96 
    0x30018: eor r1, r2, r5 
    0x3001c: str r1, [sp], #1 
    0x30020: sub r2, r2, #30 
    0x30024: eor r1, r2, r5 
    0x30028: str r1, [sp], #1 
    0x3002c: add r2, r2, #7 
    0x30030: subs r3, r3, #1 
    0x30034: bne 0x30024 
    0x30038: mov r0, #1 
    0x3003c: mov r3, #10 
    0x30040: str r3, [sp], #1 
    0x30044: mov r1, r4 
    0x30048: mov r2, #4 
    0x3004c: mov r7, #4 
    0x30050: svc 0x00000000 
    0x30054: add sp, sp, #4 
    0x30058: pop {r11, pc} 
    0x3005c: andeq r0, r0, r0
</code></pre><p>您可以看到我们有新的ARM指令我们也可以使用一个简单的idc脚本解密指令</p>
<pre><code>auto i, t;
auto start=0x200f1;
for (i=0;i&lt;=0x5C;i=i+4) 
{ 
    t = Dword(start)^0x123456;
    PatchDword(start,t);
    start=start+4;
}
</code></pre><p>我们来分析解密出来的代码</p>
<pre><code>=&gt; 0x30004:  sub sp, sp, #8 
    0x30008: mov r4, sp 
    0x3000c: mov r2, #62 ; 0x3e 
    0x30010: mov r3, #2 
    0x30014: mov r5, #150    ; 0x96 
    0x30018: eor r1, r2, r5 
    0x3001c: str r1, [sp], #1 
    0x30020: sub r2, r2, #30 
    0x30024: eor r1, r2, r5 
    0x30028: str r1, [sp], #1 
    0x3002c: add r2, r2, #7 
    0x30030: subs    r3, r3, #1 
    0x30034: bne 0x30024 
    0x30038: mov r0, #1 
    0x3003c: mov r3, #10 
    0x30040: str r3, [sp], #1 
    0x30044: mov r1, r4 
    0x30048: mov r2, #4 
    0x3004c: mov r7, #4 
    0x30050: svc 0x00000000 
    0x30054: add sp, sp, #4 
    0x30058: pop {r11, pc} 
</code></pre><p>在前五个指令（从0x30004到0x30014）之后，sp-=8（局部变量），r4=sp，r2=0x3e，r3=0x2，r5=0x96。</p>
<pre><code>(gdb) i r $r2 $r3 $r4 $r5 $sp 
r2 0x3e 62 
r3 0x2 2 
r4 0x7efff7b0 2130704304 
r5 0x96 150 
sp 0x7efff7b0 0x7efff7b0
</code></pre><p>在接下来的两个指令（0x30018和0x3001c）中，r1=r2 xor r5=0xa8中，该值保存在堆栈上，并且sp增加1在0x3001c（str r1，[sp]，＃1）的指令之后</p>
<pre><code>(gdb) x/x 0x7efff7b0 
0x7efff7b0: 0x000000a8
(gdb) i r $sp
sp 0x7efff7b1 0x7efff7b1
</code></pre><p>在地址0x30020，寄存器R2由值减去0X1E，执行后</p>
<pre><code>(gdb) i r $r2
r2 0x20 32
</code></pre><p>现在在指令0x30024有一个简单的循环</p>
<pre><code>=&gt; 0x30024:  eor r1, r2, r5 
    0x30028: str r1, [sp], #1 
    0x3002c: add r2, r2, #7 
    0x30030: subs r3, r3, #1 
    0x30034: bne 0x30024 
</code></pre><p>每次循环，都是同通过r2和r5进行xor操作，并且总是将xor操作的结果存储到堆栈中，从而增加1（sp）。我们可以看到，循环次数有r3决定，R3的初始值是2，每次循环减1，则循环执行只有2次。当循环结束时，我们到达地址0x30038，让我们看看内容在0x7efff7b0（局部变量）</p>
<pre><code>(gdb) x/4bx 0x7efff7b0 
0x7efff7b0: 0xa8 0xb6 0xb1 0x00
</code></pre><p>可以看到栈上存放了三个字节的数据，此时sp的值是</p>
<pre><code>(gdb) i r $sp    
sp 0x7efff7b3 0x7efff7b3
</code></pre><p>执行0x3003c处的两个指令后，另一个字节存储到堆栈指针中</p>
<pre><code>0x3003c: mov r3, #10 
0x30040: str r3, [sp], #1
</code></pre><p>在0x30040的指令之后，局部变量（0x7efff7b0）的内容是    (gdb) x/4bx 0x7efff7b0    0x7efff7b0: 0xa8 0xb6 0xb1 0x0a如果我们继续，调用write系统调用</p>
<pre><code>0x30038: mov r0, #1  @ fd: stdout
...
0x30044: mov r1, r4  @ buf: r4 (the buffer stored at 0xbefff7e0;)
0x30048: mov r2, #4  @ count: len of the buffer
0x3004c: mov r7, #4  @ write syscall number
0x30050: svc 0x00000000
</code></pre><p>在write系统调用之后，这是结果</p>
<pre><code>(gdb) nexti 
</code></pre><p>但是我们希望将WIN字符串作为结果，然后如本节开头所示，我们必须更改xor key以便计算出正确的值：</p>
<pre><code>0x57 0x49 0x4e
</code></pre><p>我们可以看看0x30018的第一个xor指令</p>
<pre><code>0x30018: eor r1, r2, r5
</code></pre><p>R5寄存器包含XOR key，我们要改变它，以便有</p>
<pre><code>r1 = r2 xor r5 = 0x57
</code></pre><p>r2的值为0x3e，则r5寄存器（xor键）的值应为0x69</p>
<pre><code>(gdb) set $r5=0x69
(gdb) i r $r5
r5 0x69 105
</code></pre><p>另外对于另外两次xor指令我们用相同的key，那么问题就解决了。</p>
<pre><code>(gdb) c
Continuing.
WIN
</code></pre><h3 id="基本反调试技术"><a href="#基本反调试技术" class="headerlink" title="基本反调试技术"></a>基本反调试技术</h3><p>这是本章最后一个例子，目的是了解算法并绕过一些基本的反调试技术，使得输出的消息是字符串“Good”。<br>程序：<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/anti_dbg" target="_blank" rel="external">anti_dbg</a></p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# file anti_dbg
anti_dbg: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 2.6.32, BuildID[sha1]=7028a279e2161c298caeb4db163a96ee2b2c49f3, not stripped
</code></pre><p>用调试器运行程序：</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode1# gdb -q ./anti_dbg
Reading symbols from ./anti_dbg...(no debugging symbols found)...done
(gdb) r
Starting program: /home/pi/arm/episode1/anti_dbg
You want debug me?
[Inferior 1 (process 2497) exited normally]
</code></pre><p>调试失败，即使我们使用strace/ltrace命令，也会是同样的结果。用IDA打开看看<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace1-1.png" alt=""></p>
<p>分析这个指令</p>
<pre><code>ldr r2, =aAd
</code></pre><p>将aAd变量地址给r2，看看aAd的内容<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace2.png" alt=""></p>
<p>将变量的内容以字节形式显示，以便更好的观察<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace3.png" alt=""></p>
<p>随后的两条指令将0x10988开始的四个字节放到局部变量var_C中，var_10局部变量包含了三个字节<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace4.png" alt=""></p>
<p>这三个字节通过如下指令存放到var_10变量中</p>
<pre><code>LDRH R1, [R2]                        @ load an halfword (2 byte) into R1
LDRB R2, [R2,#(unk_109CE – 0x109CC)] @ load the next byte(0x44) into r2
STRH R1, [R3]                        @ store into *R3 the first two bytes (0x22, 0x41)
STRB R2, [R3,#2]                     @ store the last byte 0x44 into *(R3+2)
</code></pre><p>现在我们有两个数组，第一个（var_C）包含4个元素</p>
<pre><code>0x7, 0x2f, 0x2f, 0x24
</code></pre><p>第二个（var_10）包含3个元素</p>
<pre><code>0x22, 0x41, 0x44
</code></pre><p>先来看看main函数逻辑，然后看看flag变量的作用<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace5.png" alt=""></p>
<p>从上图可以看出，如果标志变量等于1，执行红线后的代码，否则执行绿色行（loc_10858）后的代码（flag！= 1）<br>如果我们走flag = 1的分支，我们可以看到寄存器r3被初始化为0并且与3比较。<br>如果我们走flag != 1的分支，我们可以看到寄存器r3被初始化为0并且与2比较。<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace6.png" alt=""></p>
<p>flag = 1，我们到达loc_107F8。看看关键指令</p>
<pre><code>ADD R3, R3, #0x40
</code></pre><p>参与运算之前r3的值为</p>
<pre><code>r3 = *(var_C+var_8)
var_C = address of the array with 4 elements
var_8 = 0 index (first iteration)
</code></pre><p>在执行add指令后，r3的值为</p>
<pre><code>r3 = 0x7 + 0x40 = 0x47
</code></pre><p>我们可以创建一个简单的idc脚本来计算第一个数组的所有元素（var_C）<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace8.png" alt=""></p>
<p>看看脚本输出结果<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace7.png" alt=""></p>
<p>我们来看看flag != 1，或者说是loc_10864，这个时候是循环var_10数组，只有三个元素，循环下标index = r3。来看关键指令：</p>
<pre><code>ADD R3, R3, #0x20
</code></pre><p>跟上面一样，我们可以创建一个用于解析最终字符串的idc脚本<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace9.png" alt=""></p>
<p>输出结果<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace10.png" alt=""></p>
<p>这次的结果不是想要的我们最终需要打印”Good”,所以，现在我们需要做的就是找出怎么改变flag的值。<br>我们还可以注意到，在main函数中，没有检查调试器是否存在，也没有”You want debug me?”的字符串。<br>查看一下falg变量的引用情况<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace11.png" alt=""></p>
<p>从上图中，我们可以看到一个叫做ptrace_capt的函数，这个函数在main之前执行(你可以通过gdb在该函数上下断点来验证)，为了更深入理解，我们来看一下.ctors(或者.init_array)段，这个段记录了一个函数地址列表，这个列表里面的函数将会在程序主函数执行前/之后后被调用，我们的例子是在执行前被调用。<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace12.png" alt=""></p>
<p>查看ptrace_capt函数<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace13.png" alt=""></p>
<p>很好，我们看到ptrace检查，这是一个非常简单的检查</p>
<pre><code>if(ptrace(PTRACE_TRACEME, 0, 0, 0) &lt; 0)
{
    printf(&quot;You want debug me?\n&quot;);
    exit(0);
}
</code></pre><p>我们很快可以看到，如何轻松地绕过这个检查。继续并分析loc_10690中的代码<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace14.png" alt=""></p>
<p>我们可以总结一下流程：</p>
<p>1.打开文件password.raw</p>
<pre><code>fopen(&quot;password.raw&quot;, &quot;r&quot;)
</code></pre><p>2.计算大小</p>
<pre><code>.text:000106B4 LDR R0, [R11,#var_10] ; load the file descriptor into r0
.text:000106B8 MOV R1, #0            ; offset
.text:000106BC MOV R2, #2            ; SEEK_END
.text:000106C0 BL fseek              ; seek to end of file
.text:000106C4 LDR R0, [R11,#var_10] ; load the file descriptor into r0
.text:000106C8 BL ftell              ; size
</code></pre><p>3.验证文件大小是否小于6</p>
<pre><code>.text:000106E4 LDR R3, [R11,#var_14]
.text:000106E8 CMP R3, #6
.text:000106EC BLS loc_106F
.text:000106F0 MOV R0, #0
.text:000106F4 BL exit
</code></pre><p>如果文件大小小于6，我们到达loc_10700。否则程序结束<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace15.png" alt=""></p>
<p>如果我们继续下去，我们可以看到它是一个循环<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace16.png" alt=""></p>
<p>看看fgetc做了什么</p>
<pre><code>.text:00010700 LDR R0, [R11,#var_10] ; load into r0 the file descriptor
.text:00010704 BL fgetc
.text:00010708 STR R0, [R11,#var_18  ; save r0 into the local variable var_18
after we have the function feof
.text:0001070C LDR R0, [R11,#var_10] ; load into r0 the file descriptor
.text:00010710 BL feof
.text:00010714 MOV R3, R0            ; mov the reterun value into r3
.text:00010718 CMP R3, #0            ; compare r3 with 0
.text:0001071C BEQ loc_10750         ; associated with the stream is not set (r3=0) branch to loc_10750
</code></pre><p>如果r3等于0(表示没有到文件末尾)</p>
<pre><code>.text:00010750 loc_10750 ; CODE XREF: ptrace_capt+D0#j
.text:00010750 SUB R3, R11, #-var_1C  ; r3 = address of var_1C
.text:00010754 LDR R0, [R11,#var_18]  ; r0 ← *(r11+var_18)
.text:00010758 LDR R1, [R11,#var_8]   ; r1 ← *(r11+var_8)
.text:0001075C MOV R2, R3             ; r2 = r3
.text:00010760 BL sub0
</code></pre><p>var_18是读取的字符，第一次循环中的var_8（index）的值为0.然后我们有</p>
<pre><code>sub0(var_18, var_8, &amp;var_1C);
</code></pre><p>在下图中我们可以看到sub0函数的代码<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace17.png" alt=""></p>
<p>翻译成一个伪C代码：</p>
<pre><code>if(var_C==0 || var_C==2)
{
    //loc_1060C
    *var_10=var_8|0x55;
}
else
{
    //loc_10620
    *var_10=var_8^0x69 | var_8&lt;&lt;3;
}
</code></pre><p>当函数sub0返回时，执行以下代码（记住var_1C包含返回的值）</p>
<pre><code>.text:00010764 LDR R3, [R11,#var_1C]
.text:00010768 LDR R2, [R11,#var_C]
.text:0001076C ADD R3, R2, R3
.text:00010770 STR R3, [R11,#var_C]
.text:00010774 LDR R3, [R11,#var_8]
.text:00010778 ADD R3, R3, #1
.text:0001077C STR R3, [R11,#var_8]
.text:00010780 B loc_10700
</code></pre><p>我们可以写相应的伪C代码</p>
<pre><code>var_C = var_1C + var_C;
var_8++; //increment the index
</code></pre><p>当r3 != 0（到达文件的末尾）</p>
<pre><code>.text:00010720 LDR R3, [R11,#var_C]
.text:00010724 LDR R2, =0x997
.text:00010728 CMP R3, R2
.text:0001072C BNE loc_10740
.text:00010730 LDR R3, =flag
.text:00010734 MOV R2, #1
.text:00010738 STR R2, [R3]
.text:0001073C B loc_10784
.text:00010740 loc_10740 ; CODE XREF: ptrace_capt+E0#j
.text:00010740 LDR R3, =flag
.text:00010744 MOV R2, #2
.text:00010748 STR R2, [R3]
.text:0001074C B loc_10784
</code></pre><p>在这种情况下，我们也可以编写伪C代码</p>
<pre><code>if (var_C==0x997)
{
    flag=1;
}
else
{
    //loc_10740
    flag=2;
}
</code></pre><p>从上面的代码中看到如何改变flag变量的值我们必须首先创建password.raw文件，并在文件中写入5个字符</p>
<pre><code>#vim password.raw
bbbbb
</code></pre><p>我使用vim与删除新行（LF）</p>
<pre><code>:set noendofline binary
</code></pre><p>运行程序<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace18.png" alt=""></p>
<p>我们需要使用gdb运行它，顺便过掉ptrace。</p>
<pre><code>#gdb ./3b
</code></pre><p><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace19.png" alt=""></p>
<p>然后我们可以设置一个断点在0x10678，并修改r3的值，以绕过ptrace检查<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace20.png" alt=""></p>
<p>现在我们可以继续使用gdb进行分析，我的策略非常简单，我只想改变最后一个字节，检查flag是否等于1（var_C = 0x997）。我在文件中写道</p>
<p>|-|-|-|-|-|<br>|b|b|b|b|b|<br>|1|2|3|4|5|</p>
<p>我只想改变第五个字节使得var_C = 0x997。为了做到这一点，我们需要在第4步中知道var_C的值。<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace21.png" alt=""></p>
<p>从上图可以看出，索引为3（交互4），var_C的值为0x724。让我们尝试改变第五个字节使得var_C = 0x977我写了一个简单的<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode1/python_Script/antiDbgAlgho.py" target="_blank" rel="external">python脚本</a>来改变第五个字节</p>
<pre><code>num = 0x997-0x724
for c in range (0x20,0x7f):
    ref = c^0x69 | (c&lt;&lt;3)
    if (ref==num):
        print &quot;The number is &quot; + hex(c)
print &quot;End!&quot;
</code></pre><p>运行python脚本</p>
<pre><code>#python antDgbAlgho.py
The number is 0x4a
End!
</code></pre><p>我们得到第五个字节的正确值，现在我们可以修改文件password.raw</p>
<pre><code>#vim password.raw
bbbbJ
</code></pre><p>记住删除新行（LF）的设置</p>
<pre><code>:set noendofline binary
</code></pre><p>启动程序<br><img src="/2017/09/27/ARM-exploitation-for-IoT-–-Episode-1/ptrace22.png" alt=""></p>
<p>输出想要的结果”Good”</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/27/路由器固件安全分析技术-一/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          路由器固件安全分析技术(一)
        
      </div>
    </a>
  
  
    <a href="/2017/09/27/Burglar-and-Hacker/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Burglar and Hacker</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#动机和简介"><span class="nav-number">1.</span> <span class="nav-text">动机和简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#逆向ARM应用程序"><span class="nav-number">2.</span> <span class="nav-text">逆向ARM应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器"><span class="nav-number">2.1.</span> <span class="nav-text">编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码"><span class="nav-number">2.2.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译选项"><span class="nav-number">2.3.</span> <span class="nav-text">编译选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试符号"><span class="nav-number">2.4.</span> <span class="nav-text">调试符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除所有符号表和重定位信息"><span class="nav-number">2.5.</span> <span class="nav-text">删除所有符号表和重定位信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-Hello-World"><span class="nav-number">2.6.</span> <span class="nav-text">ARM Hello World</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Raspbian系统调用"><span class="nav-number">2.6.1.</span> <span class="nav-text">使用Raspbian系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用libc函数"><span class="nav-number">2.6.2.</span> <span class="nav-text">使用libc函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逆向工程介绍"><span class="nav-number">2.7.</span> <span class="nav-text">逆向工程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逆向算法"><span class="nav-number">2.7.1.</span> <span class="nav-text">逆向算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逆向一个简单的加载器"><span class="nav-number">2.7.2.</span> <span class="nav-text">逆向一个简单的加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本反调试技术"><span class="nav-number">2.7.3.</span> <span class="nav-text">基本反调试技术</span></a></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 物联网安全技术研究 All Rights Reserved.
          
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/主页" class="mobile-nav-link">Home</a>
  
    <a href="/书籍" class="mobile-nav-link">books</a>
  
    <a href="/工具" class="mobile-nav-link">tools</a>
  
    <a href="/关于我们" class="mobile-nav-link">about</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
